<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/07-designing-specs/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:41 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 7: Designing Specifications
   </title>
   <link href="../../web/handout-style.css" rel="stylesheet">
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_7_designing_specifications">
      Reading 7: Designing Specifications
     </a>
    </li>
    <li>
     <a href="#introduction">
      Introduction
     </a>
    </li>
    <li>
     <a href="#deterministic_vs_underdetermined_specs">
      Deterministic vs. underdetermined specs
     </a>
    </li>
    <li>
     <a href="#declarative_vs_operational_specs">
      Declarative vs. operational specs
     </a>
    </li>
    <li>
     <a href="#stronger_vs_weaker_specs">
      Stronger vs. weaker specs
     </a>
    </li>
    <li>
     <a href="#diagramming_specifications">
      Diagramming specifications
     </a>
    </li>
    <li>
     <a href="#designing_good_specifications">
      Designing good specifications
     </a>
    </li>
    <li>
     <a href="#precondition_or_postcondition">
      Precondition or postcondition?
     </a>
    </li>
    <li>
     <a href="#about_access_control">
      About access control
     </a>
    </li>
    <li>
     <a href="#about_static_vs_instance_methods">
      About static vs. instance methods
     </a>
    </li>
    <li>
     <a href="#summary">
      Summary
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_7_designing_specifications">
    Reading 7: Designing Specifications
   </h1>
   <div data-outline="reading_7_designing_specifications">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <h4>
      Software in 6.005
     </h4>
     <table class="table table-striped no-markdown">
      <tbody>
       <tr>
        <th width="33%">
         Safe from bugs
        </th>
        <th>
         Easy to understand
        </th>
        <th>
         Ready for change
        </th>
       </tr>
       <tr>
        <td>
         Correct today and correct in the unknown future.
        </td>
        <td>
         Communicating clearly with future programmers, including future you.
        </td>
        <td>
         Designed to accommodate change without rewriting.
        </td>
       </tr>
      </tbody>
     </table>
     <h4>
      Objectives
     </h4>
     <ul>
      <li>
       Understand underdetermined specs, and be able to identify and assess nondeterminism
      </li>
      <li>
       Understand declarative vs. operational specs, and be able to write declarative specs
      </li>
      <li>
       Understand strength of preconditions, postconditions, and specs; and be able to compare spec strength
      </li>
      <li>
       Be able to write coherent, useful specifications of appropriate strength
      </li>
     </ul>
     <h2 id="introduction">
      Introduction
     </h2>
     <div data-outline="introduction">
      <p>
       In this reading we’ll look at different specs for similar behaviors, and talk about the tradeoffs between them.
We’ll look at three dimensions for comparing specs:
      </p>
      <ul>
       <li>
        <p>
         How
         <strong>
          deterministic
         </strong>
         it is.
Does the spec define only a single possible output for a given input, or allow the implementor to choose from a set of legal outputs?
        </p>
       </li>
       <li>
        <p>
         How
         <strong>
          declarative
         </strong>
         it is.
Does the spec just characterize
         <em>
          what
         </em>
         the output should be, or does it explicitly say
         <em>
          how
         </em>
         to compute the output?
        </p>
       </li>
       <li>
        <p>
         How
         <strong>
          strong
         </strong>
         it is.
Does the spec have a small set of legal implementations, or a large set?
        </p>
       </li>
      </ul>
      <p>
       Not all specifications we might choose for a module are equally useful, and we’ll explore what makes some specifications better than others.
      </p>
     </div>
     <h2 id="deterministic_vs_underdetermined_specs">
      Deterministic vs. underdetermined specs
     </h2>
     <div data-outline="deterministic_vs_underdetermined_specs">
      <p>
       Recall the two example implementations of
       <code>
        find
       </code>
       we began with in the
       <a href="../06-specifications/index.html">
        previous reading
       </a>
       :
      </p>
      <pre class="no-markdown"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span></span><sub><span class="hljs-function"><span class="hljs-title">First</span></span></sub><span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> val)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) {
        <span class="hljs-keyword">if</span> (arr[i] == val) <span class="hljs-keyword">return</span> i;
    }
    <span class="hljs-keyword">return</span> arr.length;
}
</code></pre>
      <pre class="no-markdown"><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span></span><sub><span class="hljs-function"><span class="hljs-title">Last</span></span></sub><span class="hljs-function"><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> val)</span> </span>{
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = arr.length - <span class="hljs-number">1</span> ; i &gt;= <span class="hljs-number">0</span>; i--) {
        <span class="hljs-keyword">if</span> (arr[i] == val) <span class="hljs-keyword">return</span> i;
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
}
</code></pre>
      <p>
       The subscripts
       <code class="no-markdown">
        <sub>
         First
        </sub>
       </code>
       and
       <code class="no-markdown">
        <sub>
         Last
        </sub>
       </code>
       are not actual Java syntax.
We’re using them here to distinguish the two implementations for the sake of discussion.
In the actual code, both implementations should be Java methods called
       <code>
        find
       </code>
       .
      </p>
      <p>
       Here is one possible specification of
       <code>
        find
       </code>
       :
      </p>
      <pre class="no-markdown">static int find<sub>ExactlyOne</sub>(int[] arr, int val)
  <em>requires</em>: val occurs <strong>exactly once</strong> in arr
  <em>effects</em>:  returns index i such that arr[i] = val
</pre>
      <p>
       This specification is
       <strong>
        deterministic
       </strong>
       : when presented with a state satisfying the precondition, the outcome is completely determined.
Only one return value and one final state is possible.
There are no valid inputs for which there is more than one valid output.
      </p>
      <p>
       Both
       <code class="no-markdown">
        find
        <sub>
         First
        </sub>
       </code>
       and
       <code class="no-markdown">
        find
        <sub>
         Last
        </sub>
       </code>
       satisfy the specification, so if this is the specification on which the clients relied, the two implementations are equivalent and substitutable for one another.
      </p>
      <p>
       Here is a slightly different specification:
      </p>
      <pre class="no-markdown">static int find<sub>OneOrMore,AnyIndex</sub>(int[] arr, int val)
  requires: val occurs in arr
  effects:  returns index i such that arr[i] = val
</pre>
      <p>
       This specification is not deterministic.
It doesn’t say which index is returned if
       <code>
        val
       </code>
       occurs more than once.
It simply says that if you look up the entry at the index given by the returned value, you’ll find
       <code>
        val
       </code>
       .
This specification allows multiple valid outputs for the same input.
      </p>
      <p>
       Note that this is different from
       <em>
        nondeterministic
       </em>
       in the usual sense of that word.
Nondeterministic code sometimes behaves one way and sometimes another, even if called in the same program with the same inputs.
This can happen, for example, when the code’s behavior depends on a random number, or when it depends on the timing of concurrent processes.
But a specification which is not deterministic doesn’t have to have a nondeterministic implementation.
It can be satisfied by a fully deterministic implementation.
      </p>
      <p>
       To avoid the confusion, we’ll refer to specifications that are not deterministic as
       <strong>
        underdetermined
       </strong>
       .
      </p>
      <p>
       This underdetermined
       <code>
        find
       </code>
       spec is again satisfied by both
       <code class="no-markdown">
        find
        <sub>
         First
        </sub>
       </code>
       and
       <code class="no-markdown">
        find
        <sub>
         Last
        </sub>
       </code>
       , each resolving the underdeterminedness in its own (fully deterministic) way.
A client of
       <code class="no-markdown">
        find
        <sub>
         OneOrMore,AnyIndex
        </sub>
       </code>
       spec can’t rely on which index will be returned if
       <code>
        val
       </code>
       appears more than once.
The spec would be satisfied by a nondeterministic implementation, too — for example, one that tosses a coin to decide whether to start searching from the beginning or the end of the array.
But in almost all cases we’ll encounter, underdeterminism in specifications offers a choice that is made by the implementor at implementation time.
An underdetermined spec is typically implemented by a fully-deterministic implementation.
      </p>
     </div>
     <h2 id="declarative_vs_operational_specs">
      Declarative vs. operational specs
     </h2>
     <div data-outline="declarative_vs_operational_specs">
      <p>
       Roughly speaking, there are two kinds of specifications.
       <em>
        Operational
       </em>
       specifications give a series of steps that the method performs; pseudocode descriptions are operational.
       <em>
        Declarative
       </em>
       specifications don’t give details of intermediate steps.
Instead, they just give properties of the final outcome, and how it’s related to the initial state.
      </p>
      <p>
       Almost always, declarative specifications are preferable.
They’re usually shorter, easier to understand, and most importantly, they don’t inadvertently expose implementation details that a client may rely on (and then find no longer hold when the implementation is changed).
For example, if we want to allow either implementation of
       <code>
        find
       </code>
       , we would
       <em>
        not
       </em>
       want to say in the spec that the method “goes down the array until it finds
       <code>
        val
       </code>
       ,” since aside from being rather vague, this spec suggests that the search proceeds from lower to higher indices and that the lowest will be returned, which perhaps the specifier did not intend.
      </p>
      <p>
       One reason programmers sometimes lapse into operational specifications is because they’re using the spec comment to explain the implementation for a maintainer.
Don’t do that.
When it’s necessary, use comments within the body of the method, not in the spec comment.
      </p>
      <p>
       For a given specification, there may be many ways to express it declaratively:
      </p>
      <pre class="no-markdown">static boolean startsWith(String str, String prefix)
 <em>effects</em>: returns true if and only if there exists String suffix
            such that prefix + suffix == str
</pre>
      <pre class="no-markdown">static boolean startsWith(String str, String prefix)
 <em>effects</em>: returns true if and only if there exists integer i
            such that str.substring(0, i) == prefix
</pre>
      <pre class="no-markdown">static boolean startsWith(String str, String prefix)
 <em>effects</em>: returns true if the first prefix.length() characters of str
            are the characters of prefix, false otherwise
</pre>
      <p>
       It’s up to us to choose the clearest specification for clients and maintainers of the code.
      </p>
     </div>
     <h2 id="stronger_vs_weaker_specs">
      Stronger vs. weaker specs
     </h2>
     <div data-outline="stronger_vs_weaker_specs">
      <p>
       Suppose you want to change a method – either how its implementation behaves, or the specification itself.
There are already clients that depend on the method’s current specification. 
How do you compare the behaviors of two specifications to decide whether it’s safe to replace the old spec with the new spec?
      </p>
      <p>
       A specification S2 is stronger than or equal to a specification S1 if
      </p>
      <ul>
       <li>
        S2’s precondition is weaker than or equal to S1’s,
        <br>
         and
        </br>
       </li>
       <li>
        S2’s postcondition is stronger than or equal to S1’s, for the states that satisfy S1’s precondition.
       </li>
      </ul>
      <p>
       If this is the case, then an implementation that satisfies S2 can be used to satisfy S1 as well, and it’s safe to replace S1 with S2 in your program.
      </p>
      <p>
       These two rules embody several ideas.
They tell you that you can always weaken the precondition; placing fewer demands on a client will never upset them.
And you can always strengthen the post-condition, which means making more promises.
      </p>
      <p>
       For example, this spec for
       <code>
        find
       </code>
       :
      </p>
      <pre class="no-markdown">static int find<sub>ExactlyOne</sub>(int[] a, int val)
  <em>requires</em>: val occurs <strong>exactly once</strong> in a
  <em>effects</em>:  returns index i such that a[i] = val
</pre>
      <p>
       can be replaced with:
      </p>
      <pre class="no-markdown">static int find<sub>OneOrMore,AnyIndex</sub>(int[] a, int val)
  <em>requires</em>: val occurs <strong>at least once</strong> in a
  <em>effects</em>:  returns index i such that a[i] = val
</pre>
      <p>
       which has a weaker precondition.
This in turn can be replaced with:
      </p>
      <pre class="no-markdown">static int find<sub>OneOrMore,FirstIndex</sub>(int[] a, int val)
  <em>requires</em>: val occurs <strong>at least once</strong> in a
  <em>effects</em>:  returns <strong>lowest</strong> index i such that a[i] = val
</pre>
      <p>
       which has a stronger postcondition.
      </p>
      <p>
       What about this specification:
      </p>
      <pre class="no-markdown">static int find<sub>CanBeMissing</sub>(int[] a, int val)
  <em>requires</em>: <strong>nothing</strong>
  <em>effects</em>:  returns index i such that a[i] = val,
              <strong>or -1 if no such i</strong>
</pre>
      <p>
       We’ll come back to
       <code class="no-markdown">
        find
        <sub>
         CanBeMissing
        </sub>
       </code>
       in the exercises.
      </p>
      <div class="panel panel-default panel-figure pull-right pull-margin">
       <object data="figures/space1.svg">
       </object>
      </div>
     </div>
     <h2 id="diagramming_specifications">
      Diagramming specifications
     </h2>
     <div data-outline="diagramming_specifications">
      <p>
       Imagine (very abstractly) the space of all possible Java methods.
      </p>
      <p>
       Each point in this space represents a method implementation.
      </p>
      <p>
       First we’ll diagram
       <code class="no-markdown">
        find
        <sub>
         First
        </sub>
       </code>
       and
       <code class="no-markdown">
        find
        <sub>
         Last
        </sub>
       </code>
       defined
       <a href="#deterministic_vs_underdetermined_specs">
        above
       </a>
       .
Look back at the code and see that
       <code class="no-markdown">
        find
        <sub>
         First
        </sub>
       </code>
       and
       <code class="no-markdown">
        find
        <sub>
         Last
        </sub>
       </code>
       are
       <em>
        not specs
       </em>
       .
They are implementations, with method bodies that implement their actual behavior.
So we denote them as points in the space.
      </p>
      <span class="clearfix">
      </span>
      <div class="panel panel-default panel-figure pull-right pull-margin">
       <object data="figures/space2.svg">
       </object>
      </div>
      <p>
       A specification defines a
       <em>
        region
       </em>
       in the space of all possible implementations.
A given implementation either behaves according to the spec, satisfying the precondition-implies-postcondition contract (it is inside the region), or it does not (outside the region).
      </p>
      <p>
       Both
       <code class="no-markdown">
        find
        <sub>
         First
        </sub>
       </code>
       and
       <code class="no-markdown">
        find
        <sub>
         Last
        </sub>
       </code>
       satisfy
       <code class="no-markdown">
        find
        <sub>
         OneOrMore,AnyIndex
        </sub>
       </code>
       , so they are inside the region defined by that spec.
      </p>
      <span class="clearfix">
      </span>
      <p>
       We can imagine clients looking in on this space: the specification acts as a firewall.
      </p>
      <ul>
       <li>
        <p>
         Implementors have the freedom to move around inside the spec, changing their code without fear of upsetting a client.
This is crucial in order for the implementor to be able to improve the performance of their algorithm, the clarity of their code, or to change their approach when they discover a bug, etc.
        </p>
       </li>
       <li>
        <p>
         Clients don’t know which implementation they will get.
They must respect the spec, but also have the freedom to change how they’re using the implementation without fear that it will suddenly break.
        </p>
       </li>
      </ul>
      <p>
       How will similar specifications relate to one another?
Suppose we start with specification S1 and use it to create a new specification S2.
      </p>
      <p>
       If S2 is stronger than S1, how will these specs appear in our diagram?
      </p>
      <ul>
       <li>
        <p>
         Let’s start by
         <strong>
          strengthening the postcondition
         </strong>
         .
If S2’s postcondition is now stronger than S1’s postcondition, then S2 is the stronger specification.
        </p>
        <p>
         Think about what strengthening the postcondition means for implementors: it means they have less freedom, the requirements on their output are stronger.
Perhaps they previously satisfied
         <code class="no-markdown">
          find
          <sub>
           OneOrMore,AnyIndex
          </sub>
         </code>
         by returning any index
         <code>
          i
         </code>
         , but now the spec demands the
         <em>
          lowest
         </em>
         index
         <code>
          i
         </code>
         .
So there are now implementations
         <em>
          inside
         </em>
         <code class="no-markdown">
          find
          <sub>
           OneOrMore,AnyIndex
          </sub>
         </code>
         but
         <em>
          outside
         </em>
         <code class="no-markdown">
          find
          <sub>
           OneOrMore,FirstIndex
          </sub>
         </code>
         .
        </p>
        <p>
         Could there be implementations
         <em>
          inside
         </em>
         <code class="no-markdown">
          find
          <sub>
           OneOrMore,FirstIndex
          </sub>
         </code>
         but
         <em>
          outside
         </em>
         <code class="no-markdown">
          find
          <sub>
           OneOrMore,AnyIndex
          </sub>
         </code>
         ?
No.
All of those implementations satisfy a stronger postcondition than what
         <code class="no-markdown">
          find
          <sub>
           OneOrMore,AnyIndex
          </sub>
         </code>
         demands.
        </p>
       </li>
       <li>
        <p>
         Think through what happens if we
         <strong>
          weaken the precondition
         </strong>
         , which will again make S2 a stronger specification.
Implementations will have to handle new inputs that were previously excluded by the spec.
If they behaved badly on those inputs before, we wouldn’t have noticed, but now their bad behavior is exposed.
        </p>
       </li>
      </ul>
      <div class="panel panel-default panel-figure pull-right pull-margin">
       <object data="figures/space3.svg">
       </object>
      </div>
      <p>
       We see that when S2 is stronger than S1, it defines a
       <em>
        smaller
       </em>
       region in this diagram; a weaker specification defines a larger region.
      </p>
      <p>
       In our figure, since
       <code class="no-markdown">
        find
        <sub>
         Last
        </sub>
       </code>
       iterates from the end of the array
       <code>
        arr
       </code>
       , it does not satisfy
       <code class="no-markdown">
        find
        <sub>
         OneOrMore,FirstIndex
        </sub>
       </code>
       and is outside that region.
      </p>
      <p>
       Another specification S3 that is neither stronger nor weaker than S1 might overlap (such that there exist implementations that satisfy only S1, only S3, and both S1 and S3) or might be disjoint.
In both cases, S1 and S3 are incomparable.
      </p>
      <span class="clearfix">
      </span>
     </div>
     <h2 id="designing_good_specifications">
      Designing good specifications
     </h2>
     <div data-outline="designing_good_specifications">
      <p>
       What makes a good method?
Designing a method means primarily writing a specification.
      </p>
      <p>
       About the form of the specification: it should obviously be succinct, clear, and well-structured, so that it’s easy to read.
      </p>
      <p>
       The content of the specification, however, is harder to prescribe.
There are no infallible rules, but there are some useful guidelines.
      </p>
      <h3 id="the_specification_should_be_coherent">
       The specification should be coherent
      </h3>
      <div data-outline="the_specification_should_be_coherent">
       <p>
        The spec shouldn’t have lots of different cases.
Long argument lists, deeply nested if-statements, and boolean flags are all signs of trouble.
Consider this specification:
       </p>
       <pre class="no-markdown">static int sumFind(int[] a, int[] b, int val)
  <em>effects</em>: returns the sum of all indices in arrays a and b at which
             val appears
</pre>
       <p>
        Is this a well-designed procedure?
Probably not: it’s incoherent, since it does several things (finding in two arrays and summing the indexes) that are not really related.
It would be better to use two separate procedures, one that finds the indexes, and the other that sums them.
       </p>
       <p>
        Here’s another example,
        <a href="../04-code-review/index.html#countLongWords">
         the
         <code>
          countLongWords
         </code>
         method from
         <em>
          Code Review
         </em>
        </a>
        :
       </p>
       <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> LONG_WORD_LENGTH = <span class="hljs-number">5</span>;
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String longestWord;

<span class="hljs-comment handout-javadoc-comment">/**
 * Update longestWord to be the longest element of words, and print
 * the number of elements with length &gt; LONG_WORD_LENGTH to the console.
 * <span class="hljs-doctag">@param</span> words list to search for long words
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countLongWords</span><span class="hljs-params">(List&lt;String&gt; words)</span></span></code></pre>
       <p>
        In addition to
        <a href="../04-code-review/index.html#dont_use_global_variables">
         terrible use of global variables
        </a>
        and
        <a href="../04-code-review/index.html#methods_should_return_results_not_print_them">
         printing instead of returning
        </a>
        , the specification is not coherent — it does two different things, counting words and finding the longest word.
       </p>
       <p>
        Separating those two responsibilities into two different methods will make them simpler (easy to understand) and more useful in other contexts (ready for change).
       </p>
      </div>
      <h3 id="the_results_of_a_call_should_be_informative">
       The results of a call should be informative
      </h3>
      <div data-outline="the_results_of_a_call_should_be_informative">
       <p>
        Consider the specification of a method that puts a value in a map, where keys are of some type
        <code>
         K
        </code>
        and values are of some type
        <code>
         V
        </code>
        :
       </p>
       <pre class="no-markdown">static V put (Map&lt;K,V&gt; map, K key, V val)
  <em>requires</em>: val may be null, and map may contain null values
  <em>effects</em>:  inserts (key, val) into the mapping,
              overriding any existing mapping for key, and
              returns old value for key, unless none,
              in which case it returns null
</pre>
       <p>
        Note that the precondition does not rule out
        <code>
         null
        </code>
        values so the map can store
        <code>
         null
        </code>
        s.
But the postcondition uses
        <code>
         null
        </code>
        as a special return value for a missing key.
This means that if
        <code>
         null
        </code>
        is returned, you can’t tell whether the key was not bound previously, or whether it was in fact bound to
        <code>
         null
        </code>
        .
This is not a very good design, because the return value is useless unless you know for sure that you didn’t insert
        <code>
         null
        </code>
        s.
       </p>
      </div>
      <h3 id="the_specification_should_be_strong_enough">
       The specification should be strong enough
      </h3>
      <div data-outline="the_specification_should_be_strong_enough">
       <p>
        Of course the spec should give clients a strong enough guarantee in the general case — it needs to satisfy their basic requirements.
We must use extra care when specifying the special cases, to make sure they don’t undermine what would otherwise be a useful method.
       </p>
       <p>
        For example, there’s no point throwing an exception for a bad argument but allowing arbitrary mutations, because a client won’t be able to determine what mutations have actually been made.
Here’s a specification illustrating this flaw (and also written in an inappropriately operational style):
       </p>
       <pre class="no-markdown">static void addAll(List&lt;T&gt; list1, List&lt;T&gt; list2)
  <em>effects</em>: adds the elements of list2 to list1,
             unless it encounters a null element,
             at which point it throws a NullPointerException
</pre>
       <p>
        If a
        <code>
         NullPointerException
        </code>
        is thrown, the client is left to figure out on their own which elements of
        <code>
         list2
        </code>
        actually made it to
        <code>
         list1
        </code>
        .
       </p>
      </div>
      <h3 id="the_specification_should_also_be_weak_enough">
       The specification should also be weak enough
      </h3>
      <div data-outline="the_specification_should_also_be_weak_enough">
       <p>
        Consider this specification for a method that opens a file:
       </p>
       <pre class="no-markdown">static File open(String filename)
  <em>effects</em>: opens a file named filename
</pre>
       <p>
        This is a bad specification.
It lacks important details: is the file opened for reading or writing?
Does it already exist or is it created?
And it’s too strong, since there’s no way it can guarantee to open a file.
The process in which it runs may lack permission to open a file, or there might be some problem with the file system beyond the control of the program.
Instead, the specification should say something much weaker: that it attempts to open a file, and if it succeeds, the file has certain properties.
       </p>
      </div>
      <h3 id="the_specification_should_use_abstract_types_where_possible">
       The specification should use
       <em>
        abstract types
       </em>
       where possible
      </h3>
      <div data-outline="the_specification_should_use_abstract_types_where_possible">
       <p>
        We saw early on in the
        <a href="../02-basic-java/index.html#arraylists_and_linkedlists_creating_lists">
         Java Collections section of
         <em>
          Basic Java
         </em>
        </a>
        that we can distinguish between more abstract notions like a
        <code>
         List
        </code>
        or
        <code>
         Set
        </code>
        and particular implementations like
        <code>
         ArrayList
        </code>
        or
        <code>
         HashSet
        </code>
        .
       </p>
       <p>
        Writing our specification with
        <em>
         abstract types
        </em>
        gives more freedom to both the client and the implementor.
In Java, this often means using an interface type, like
        <code>
         Map
        </code>
        or
        <code>
         Reader
        </code>
        , instead of specific implementation types like
        <code>
         HashMap
        </code>
        or
        <code>
         FileReader
        </code>
        .
Consider this specification:
       </p>
       <pre class="no-markdown">static ArrayList&lt;T&gt; reverse(ArrayList&lt;T&gt; list)
  <em>effects</em>: returns a new list which is the reversal of list, i.e.
             newList[i] == list[n-i-1]
             for all 0 &lt;= i &lt; n, where n = list.size()
</pre>
       <p>
        This forces the client to pass in an
        <code>
         ArrayList
        </code>
        , and forces the implementor to return an
        <code>
         ArrayList
        </code>
        , even if there might be alternative
        <code>
         List
        </code>
        implementations that they would rather use.
Since the behavior of the specification doesn’t depend on anything specific about
        <code>
         ArrayList
        </code>
        , it would be better to write this spec in terms of the more abstract
        <code>
         List
        </code>
        .
       </p>
      </div>
     </div>
     <h2 id="precondition_or_postcondition">
      Precondition or postcondition?
     </h2>
     <div data-outline="precondition_or_postcondition">
      <p>
       Another design issue is whether to use a precondition, and if so, whether the method code should attempt to make sure the precondition has been met before proceeding.
In fact, the most common use of preconditions is to demand a property precisely because it would be hard or expensive for the method to check it.
      </p>
      <p>
       As mentioned above, a non-trivial precondition inconveniences clients, because they have to ensure that they don’t call the method in a bad state (that violates the precondition); if they do, there is no predictable way to recover from the error.
So users of methods don’t like preconditions.
That’s why the Java API classes, for example, tend to specify (as a postcondition) that they throw unchecked exceptions when arguments are inappropriate.
This approach makes it easier to find the bug or incorrect assumption in the caller code that led to passing bad arguments.
In general, it’s better to
       <strong>
        fail fast
       </strong>
       , as close as possible to the site of the bug, rather than let bad values propagate through a program far from their original cause.
      </p>
      <p>
       Sometimes, it’s not feasible to check a condition without making a method unacceptably slow, and a precondition is often necessary in this case.
If we wanted to implement the
       <code>
        find
       </code>
       method using binary search, we would have to require that the array be sorted.
Forcing the method to actually
       <em>
        check
       </em>
       that the array is sorted would defeat the entire purpose of the binary search: to obtain a result in logarithmic and not linear time.
      </p>
      <p>
       The decision of whether to use a precondition is an engineering judgment.
The key factors are the cost of the check (in writing and executing code), and the scope of the method.
If it’s only called locally in a class, the precondition can be discharged by carefully checking all the sites that call the method.
But if the method is public, and used by other developers, it would be less wise to use a precondition.
Instead, like the Java API classes, you should throw an exception.
      </p>
     </div>
     <h2 id="about_access_control">
      About access control
     </h2>
     <div data-outline="about_access_control">
      <div class="handout-solo alert alert-warning">
       <p>
        Read:
        <strong>
         <a class="alert-link" href="http://docs.oracle.com/javase/tutorial/java/package/index.html">
          Packages
         </a>
        </strong>
        (7 short pages) in the Java Tutorials.
       </p>
      </div>
      <div class="handout-solo alert alert-warning">
       <p>
        Read:
        <strong>
         <a class="alert-link" href="http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">
          Controlling Access
         </a>
        </strong>
        (1 page) in the Java Tutorials.
       </p>
      </div>
      <p>
       We have been using
       <em>
        public
       </em>
       for almost all of our methods, without really thinking about it.
The decision to make a method public or private is actually a decision about the contract of the class.
Public methods are freely accessible to other parts of the program.
Making a method public advertises it as a service that your class is willing to provide.
If you make all your methods public — including helper methods that are really meant only for local use within the class — then other parts of the program may come to depend on them, which will make it harder for you to change the internal implementation of the class in the future.
Your code won’t be as
       <strong>
        ready for change
       </strong>
       .
      </p>
      <p>
       Making internal helper methods public will also add clutter to the visible interface your class offers.
Keeping internal things
       <em>
        private
       </em>
       makes your class’s public interface smaller and more coherent (meaning that it does one thing and does it well).
Your code will be
       <strong>
        easier to understand
       </strong>
       .
      </p>
      <p>
       We will see even stronger reasons to use
       <em>
        private
       </em>
       in the next few classes, when we start to write classes with persistent internal state.
Protecting this state will help keep the program
       <strong>
        safe from bugs
       </strong>
       .
      </p>
     </div>
     <h2 id="about_static_vs_instance_methods">
      About static vs. instance methods
     </h2>
     <div data-outline="about_static_vs_instance_methods">
      <div class="handout-solo alert alert-warning">
       <p>
        Read:
        <strong>
         <a class="alert-link" href="http://www.codeguru.com/java/tij/tij0037.shtml#Heading79">
          the
          <code>
           static
          </code>
          keyword
         </a>
        </strong>
        on CodeGuru.
       </p>
      </div>
      <p>
       We have also been using
       <em>
        static
       </em>
       for almost all of our methods, again without much discussion.
Static methods are not associated with any particular instance of a class, while
       <em>
        instance
       </em>
       methods (declared without the
       <code>
        static
       </code>
       keyword) must be called on a particular object.
      </p>
      <p>
       Specifications for instance methods are written just the same way as specifications for static methods, but they will often refer to properties of the instance on which they were called.
      </p>
      <p>
       For example, by now we’re very familiar with this specification:
      </p>
      <pre class="no-markdown">static int find(int[] arr, int val)
  <em>requires</em>: val occurs in arr
  <em>effects</em>:  returns index i such that arr[i] = val
</pre>
      <p>
       Instead of using an
       <code>
        int[]
       </code>
       , what if we had a class
       <code>
        IntArray
       </code>
       designed for storing arrays of integers?
The
       <code>
        IntArray
       </code>
       class might provide an instance method with the specification:
      </p>
      <pre class="no-markdown">int find(int val)
  <em>requires</em>: val occurs in <stong>this array
  <em>effects</em>:  returns index i such that <strong>the value at index i in this array</strong>
              is val
</stong></pre>
      <p>
       We’ll have much more to say about specifications for instance methods in future classes!
      </p>
     </div>
     <h2 id="summary">
      Summary
     </h2>
     <div data-outline="summary">
      <p>
       A specification acts as a crucial firewall between implementor and client — both between people (or the same person at different times) and between code.
       <a href="../06-specifications/index.html#summary">
        As we saw last time
       </a>
       , it makes separate development possible: the client is free to write code that uses a module without seeing its source code, and the implementor is free to write the implementation code without knowing how it will be used.
      </p>
      <p>
       Declarative specifications are the most useful in practice.
Preconditions (which weaken the specification) make life harder for the client, but applied judiciously they are a vital tool in the software designer’s repertoire, allowing the implementor to make necessary assumptions.
      </p>
      <p>
       As always, our goal is to design specifications that make our software:
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Safe from bugs
         </strong>
         .
Without specifications, even the tiniest change to any part of our program could be the tipped domino that knocks the whole thing over.
Well-structured, coherent specifications minimize misunderstandings and maximize our ability to write correct code with the help of static checking, careful reasoning, testing, and code review.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Easy to understand
         </strong>
         .
A well-written declarative specification means the client doesn’t have to read or understand the code.
You’ve probably never read the code for, say,
         <a href="https://hg.python.org/cpython/file/7ae156f07a90/Objects/dictobject.c#l1990">
          Python
          <code>
           dict.update
          </code>
         </a>
         , and doing so isn’t nearly as useful to the Python programmer as
         <a href="https://docs.python.org/3/library/stdtypes.html#dict.update">
          reading the declarative spec
         </a>
         .
        </p>
       </li>
       <li>
        <p>
         <strong>
          Ready for change
         </strong>
         .
An appropriately weak specification gives freedom to the implementor, and an appropriately strong specification gives freedom to the client.
We can even change the specs themselves, without having to revisit every place they’re used, as long as we’re only strengthening them: weakening preconditions and strengthening postconditions.
        </p>
       </li>
      </ul>
     </div>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/07-designing-specs/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:45 GMT -->
</html>
<!-- Handout delivered Thu May 05 2016 15:22:53 GMT-0400 (EDT) -->
