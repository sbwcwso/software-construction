<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/16-recursive-data-types/matexpr/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:37:19 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 16, Part 2: Writing a Program with Abstract Data Types
   </title>
   <link href="../../../web/handout-style.css" rel="stylesheet">
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_16_part_2_writing_a_program_with_abstract_data_types">
      Reading 16, Part 2: Writing a Program with Abstract Data Types
     </a>
    </li>
    <li>
     <a href="#recipes_for_programming">
      Recipes for programming
     </a>
    </li>
    <li>
     <a href="#problem_matrix_multiplication">
      Problem: matrix multiplication
     </a>
    </li>
    <li>
     <a href="#next_summary">
      Next: Summary
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_16_part_2_writing_a_program_with_abstract_data_types">
    Reading 16, Part 2: Writing a Program with Abstract Data Types
   </h1>
   <div data-outline="reading_16_part_2_writing_a_program_with_abstract_data_types">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <p>
      Bringing together what we’ve learned about abstract data types, this reading demonstrates the development of an ADT to solve a simple problem.
     </p>
     <h2 id="recipes_for_programming">
      Recipes for programming
     </h2>
     <div data-outline="recipes_for_programming">
      <div class="list-style-sub-lower-alpha">
       <p>
        Recall the test-first programming approach for
        <br>
         <strong>
          Writing a procedure
         </strong>
         (a static method):
        </br>
       </p>
       <ol>
        <li>
         <strong>
          Spec.
         </strong>
         Write the spec, including the method signature (name, argument types, return types, exceptions), and the precondition and the postcondition as a Javadoc comment.
        </li>
        <li>
         <strong>
          Test.
         </strong>
         Create systematic test cases and put them in a JUnit class so you can run them automatically.
         <ol>
          <li>
           You may have to go back and change your spec when you start to write test cases.
Just the process of writing test cases puts pressure on your spec, because you’re thinking about how a client would call the method.
So steps 1 and 2 iterate until you’ve got a better spec and some good test cases.
          </li>
          <li>
           Make sure at least some of your tests are
           <em>
            failing
           </em>
           at first.
A test suite that passes all tests even when you haven’t implemented the method is not a good test suite for finding bugs.
          </li>
         </ol>
        </li>
        <li>
         <strong>
          Implement.
         </strong>
         Write the body of the method.
You’re done when the tests are all green in JUnit.
         <ol>
          <li>
           Implementing the method puts pressure on both the tests and the specs, and you may find bugs in them that you have to go back and fix.
So finishing the job may require changing the implementation, the tests, and the specs, and bouncing back and forth among them.
          </li>
         </ol>
        </li>
       </ol>
       <p>
        Let’s broaden this to a recipe for
        <br>
         <strong>
          Writing an abstract data type
         </strong>
         :
        </br>
       </p>
       <ol>
        <li>
         <strong>
          Spec.
         </strong>
         Write specs for the operations of the datatype, including method signatures, preconditions, and postconditions.
        </li>
        <li>
         <strong>
          Test.
         </strong>
         Write test cases for the ADT’s operations.
         <ol>
          <li>
           Again, this puts pressure on the spec.
You may discover that you need operations you hadn’t anticipated, so you’ll have to add them to the spec.
          </li>
         </ol>
        </li>
        <li>
         <strong>
          Implement.
         </strong>
         For an ADT, this part expands to:
         <ol>
          <li>
           <strong>
            Choose rep.
           </strong>
           Write down the private fields of a class, or the variants of a recursive datatype.
Write down the rep invariant as a comment.
          </li>
          <li>
           <strong>
            Assert rep invariant.
           </strong>
           Implement a
           <code>
            checkRep()
           </code>
           method that enforces the rep invariant.
This is critically important if the rep invariant is nontrivial, because it will catch bugs much earlier.
          </li>
          <li>
           <strong>
            Implement operations.
           </strong>
           Write the method bodies of the operations, making sure to call
           <code>
            checkRep()
           </code>
           in them.
You’re done when the tests are all green in JUnit.
          </li>
         </ol>
        </li>
       </ol>
       <p>
        And let’s broaden it further to a recipe for
        <br>
         <strong>
          Writing a program
         </strong>
         (consisting of ADTs and procedures):
        </br>
       </p>
       <ol>
        <li>
         <strong>
          Choose datatypes.
         </strong>
         Decide which ones will be mutable and which immutable.
        </li>
        <li>
         <strong>
          Choose procedures.
         </strong>
         Write your top-level procedure and break it down into smaller steps.
        </li>
        <li>
         <strong>
          Spec.
         </strong>
         Spec out the ADTs and procedures.
Keep the ADT operations simple and few at first.
Only add complex operations as you need them.
        </li>
        <li>
         <strong>
          Test.
         </strong>
         Write test cases for each unit (ADT or procedure).
        </li>
        <li>
         <strong>
          Implement simply first.
         </strong>
         Choose simple, brute-force representations.
The point here is to put pressure on the specs and the tests, and try to pull your whole program together as soon as possible.
Make the whole program work correctly first.
Skip the advanced features for now.
Skip performance optimization.
Skip corner cases.
Keep a to-do list of what you have to revisit.
        </li>
        <li>
         <strong>
          Reimplement and iterate and optimize.
         </strong>
         Now that it’s all working, make it work better.
        </li>
       </ol>
      </div>
     </div>
     <h2 id="problem_matrix_multiplication">
      Problem: matrix multiplication
     </h2>
     <div data-outline="problem_matrix_multiplication">
      <p>
       Suppose we want to compute matrix multiplications and we want to do them faster.
      </p>
      <p>
       For example, if
       <em>
        a
       </em>
       ,
       <em>
        b
       </em>
       are scalar constants, and
       <em>
        X
       </em>
       is a big matrix, then
      </p>
      <blockquote>
       <p>
        <em>
         (aX)b
        </em>
       </p>
      </blockquote>
      <p>
       is slow to compute because it loops over the matrix
       <em>
        X
       </em>
       twice: once to multiply it by
       <em>
        a
       </em>
       , and then again to multiply it by
       <em>
        b
       </em>
       .
It’d be equivalent and cheaper to do:
      </p>
      <blockquote>
       <p>
        <em>
         (ab)X
        </em>
       </p>
      </blockquote>
      <p>
       That’s just one example of an optimization we could make by rearranging the products in a matrix multiplication.
(Remember however that matrix multiplication is associative but not commutative; only scalars commute.)
      </p>
      <h3 id="choose_datatypes">
       Choose datatypes
      </h3>
      <div data-outline="choose_datatypes">
       <p>
        Let’s call this a
        <code>
         MatrixExpression
        </code>
        .
To make the definitions easier to read, we’ll abbreviate that to
        <code>
         MatExpr
        </code>
        .
       </p>
       <p>
        Let’s define some operations:
       </p>
       <p>
        <strong>
         make
        </strong>
        : double → MatExpr
        <br>
         // effects: returns an expression consisting of just the given scalar
        </br>
       </p>
       <p>
        <strong>
         make
        </strong>
        : double[][] → MatExpr
        <br>
         // requires: array.length &gt; 0, and array[i].lengths are equal and &gt; 0, for all i
         <br>
          // effects: returns an expression consisting of just the given matrix
         </br>
        </br>
       </p>
       <p>
        <strong>
         times
        </strong>
        : MatExpr × MatExpr → MatExpr
        <br>
         // requires: m1 and m2 are compatible for multiplication
         <br>
          // effects: returns m1×m2
         </br>
        </br>
       </p>
       <p>
        <strong>
         isIdentity
        </strong>
        : MatExpr → boolean
        <br>
         // effects: returns true if the expression is the multiplicative identity
        </br>
       </p>
       <p>
        And the one we really want:
       </p>
       <p>
        <strong>
         optimize
        </strong>
        : MatExpr → MatExpr
        <br>
         // effects: returns an expression with the same value, but which may be faster to compute
        </br>
       </p>
      </div>
      <h3 id="test">
       Test
      </h3>
      <div data-outline="test">
       <p>
        Let’s test
        <code>
         optimize()
        </code>
        .
Partitions:
       </p>
       <ul>
        <li>
         Number of scalars in expression: 0, 1, 2, &gt;2
        </li>
        <li>
         Position of scalar in expression tree: immediate left, immediate right, left-of-left, left-of-right, right-of-left, right-of-right
        </li>
       </ul>
       <table class="table">
        <thead>
         <tr>
          <th>
           Test case
          </th>
          <th>
          </th>
          <th>
           Partitions covered
          </th>
         </tr>
        </thead>
        <tbody>
         <tr>
          <td>
           X ⇒ X
          </td>
          <td>
           covers
          </td>
          <td>
           0 scalars
          </td>
         </tr>
         <tr>
          <td>
           aX ⇒ aX
          </td>
          <td>
          </td>
          <td>
           1 scalar, immediate left
          </td>
         </tr>
         <tr>
          <td>
           a(Xb) ⇒ (ab)X
          </td>
          <td>
          </td>
          <td>
           2 scalars, immediate left, right-of-right
          </td>
         </tr>
         <tr>
          <td>
           (aX)b ⇒ (ab)X
          </td>
          <td>
          </td>
          <td>
           2 scalars, immediate right, left-of-left
          </td>
         </tr>
         <tr>
          <td>
           (Xa)(bY) ⇒ (((ab)X)Y)
          </td>
          <td>
          </td>
          <td>
           2 scalars, left-of-right, right-of-left
          </td>
         </tr>
        </tbody>
       </table>
      </div>
      <h3 id="choose_a_rep">
       Choose a rep
      </h3>
      <div data-outline="choose_a_rep">
       <p>
        This problem is a natural one for a recursive datatype.
       </p>
       <blockquote>
        <p>
         MatExpr = Identity + Scalar(double) + Matrix(double[][]) + Product(MatExpr, MatExpr)
        </p>
       </blockquote>
       <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/** Represents an immutable expression of matrix and scalar products. */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Identity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Identity</span><span class="hljs-params">()</span> </span>{
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scalar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> value;
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Scalar</span><span class="hljs-params">(<span class="hljs-keyword">double</span> value)</span> </span>{
        <span class="hljs-keyword">this</span>.value = value;
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span>[][] array;
    <span class="hljs-comment">// RI: array.length &gt; 0, and all array[i] are equal nonzero length</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Matrix</span><span class="hljs-params">(<span class="hljs-keyword">double</span>[][] array)</span> </span>{
        <span class="hljs-keyword">this</span>.array = array; <span class="hljs-comment">// note: danger!</span>
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MatrixExpression m1;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MatrixExpression m2;
    <span class="hljs-comment">// RI: m1's column count == m2's row count, or m1 or m2 is scalar</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(MatrixExpression m1, MatrixExpression m2)</span> </span>{
        <span class="hljs-keyword">this</span>.m1 = m1;
        <span class="hljs-keyword">this</span>.m2 = m2;
    }
}</code></pre>
      </div>
      <h3 id="choose_an_identity">
       Choose an identity
      </h3>
      <div data-outline="choose_an_identity">
       <p>
        It’s always good to have a value in the datatype that represents nothing, so that we can avoid using
        <code>
         null
        </code>
        .
For a matrix product, the natural choice is the identity matrix — an empty product expression is just the identity anyway.
So let’s define that:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/** Identity for all matrix computations. */</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> MatrixExpression I = <span class="hljs-keyword">new</span> Identity();</code></pre>
       <p>
        Unfortunately, we’ll see that this is not a perfect situation: other MatExprs might
        <em>
         also
        </em>
        be the identity.
       </p>
      </div>
      <h3 id="implementing_make_use_factory_methods">
       Implementing
       <code>
        make
       </code>
       : use factory methods
      </h3>
      <div data-outline="implementing_make_use_factory_methods">
       <p>
        Let’s start implementing, starting with the
        <code>
         make()
        </code>
        creators.
       </p>
       <p>
        We don’t want to expose our concrete rep classes
        <code>
         Scalar
        </code>
        ,
        <code>
         Matrix
        </code>
        , and
        <code>
         Product
        </code>
        , so that clients won’t depend on them and we’ll be able to change them later (being
        <em>
         ready for change
        </em>
        ).
       </p>
       <p>
        So we’ll create static methods in
        <code>
         MatrixExpression
        </code>
        to implement
        <code>
         make()
        </code>
        :
       </p>
       <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/** <span class="hljs-doctag">@return</span> a matrix expression consisting of just the scalar value */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MatrixExpression <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">double</span> value)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Scalar(value);
}

<span class="hljs-comment handout-javadoc-comment">/** <span class="hljs-doctag">@return</span> a matrix expression consisting of just the matrix given */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MatrixExpression <span class="hljs-title">make</span><span class="hljs-params">(<span class="hljs-keyword">double</span>[][] array)</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Matrix(array);
}</code></pre>
       <p>
        These are called
        <strong>
         factory methods
        </strong>
        — static methods that play the role of constructors.
The factory-method pattern is a common design pattern that you’ll see throughout object-oriented programming, in many languages.
       </p>
      </div>
      <h3 id="implementing_isidentity_dont_use_instanceof">
       Implementing
       <code>
        isIdentity
       </code>
       : don’t use
       <code>
        instanceof
       </code>
      </h3>
      <div data-outline="implementing_isidentity_dont_use_instanceof">
       <p>
        Now let’s implement the
        <code>
         isIdentity
        </code>
        observer.
Here’s a
        <strong>
         bad
        </strong>
        way to do it:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-comment">// don't do this</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIdentity</span><span class="hljs-params">(MatrixExpression m)</span> </span>{
    <span class="hljs-keyword">if</span> (m <span class="hljs-keyword">instanceof</span> Scalar) {
        <span class="hljs-keyword">return</span> ((Scalar)m).value == <span class="hljs-number">1</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m <span class="hljs-keyword">instanceof</span> Matrix) {
        <span class="hljs-comment">// ... check for 1s on the diagonal and 0s everywhere else</span>
    } <span class="hljs-keyword">else</span> ... <span class="hljs-comment">// do the right thing for other variant classes</span>
}</code></pre>
       <p>
        In general, using
        <code>
         instanceof
        </code>
        in object-oriented programming is a bad smell.
Break the operation down into pieces that are appropriate for each class, and write instance methods instead:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Identity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIdentity</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scalar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIdentity</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> value == <span class="hljs-number">1</span>; }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIdentity</span><span class="hljs-params">()</span> </span>{ 
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> row = <span class="hljs-number">0</span>; row &lt; array.length; row++) {
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> col = <span class="hljs-number">0</span>; col &lt; array[row].length; col++) {
                <span class="hljs-keyword">double</span> expected = (row == col) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;
                <span class="hljs-keyword">if</span> (array[row][col] != expected) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
            }
        }
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isIdentity</span><span class="hljs-params">()</span> </span>{ 
        <span class="hljs-keyword">return</span> m1.isIdentity() &amp;&amp; m2.isIdentity();
    }
}</code></pre>
       <p>
        Implementing
        <code>
         isIdentity
        </code>
        exposes an issue that we
        <em>
         should
        </em>
        have first discovered by writing test cases: we will not always return
        <code>
         true
        </code>
        for a
        <code>
         Product
        </code>
        whose value is the identity matrix (e.g. A × A
        <sup class="no-markdown">
         -1
        </sup>
        ).
We probably want to resolve this by
        <em>
         weakening
        </em>
        the spec of
        <code>
         isIdentity
        </code>
        .
       </p>
      </div>
      <h3 id="implementing_optimize_without_instanceof">
       Implementing
       <code>
        optimize
       </code>
       without
       <code>
        instanceof
       </code>
      </h3>
      <div data-outline="implementing_optimize_without_instanceof">
       <p>
        Let’s implement
        <code>
         optimize()
        </code>
        .
Again, here’s a
        <strong>
         bad
        </strong>
        way to do it, which will quickly get us mired in weeds:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-comment">// don't do this</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">optimize</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">if</span> (m1 <span class="hljs-keyword">instanceof</span> Scalar) {
            ...
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m2 <span class="hljs-keyword">instanceof</span> Scalar) {
            ...
        }
        ...
}</code></pre>
       <p>
        If you find yourself writing code with
        <code>
         instanceof
        </code>
        checks all over the place, you need to take a step back and rethink the problem.
       </p>
       <p>
        In particular, to optimize the scalars, we’re going to need two recursive helper operations, so we’ll add them to our abstract datatype:
       </p>
       <p>
        <strong>
         scalars
        </strong>
        : MatExpr → MatExpr
        <br>
         // effects: returns a MatExpr with no matrices in it, only the scalars
        </br>
       </p>
       <p>
        <strong>
         matrices
        </strong>
        : MatExpr → MatExpr
        <br>
         // effects: returns a MatExpr with no scalars in it, only matrices in the same order they appear in the input expression
        </br>
       </p>
       <p>
        These expressions will allow us to pull the scalars out of an expression and move them together in a single multiplication expression.
       </p>
       <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/** Represents an immutable expression of matrix and scalar products. */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MatrixExpression</span> </span>{

    <span class="hljs-comment">// ...</span>

    <span class="hljs-comment handout-javadoc-comment">/** <span class="hljs-doctag">@return</span> the product of all the scalars in this expression */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">scalars</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment handout-javadoc-comment">/** <span class="hljs-doctag">@return</span> the product of all the matrices in this expression.
     * times(scalars(), matrices()) is equivalent to this expression. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">matrices</span><span class="hljs-params">()</span></span>;
}</code></pre>
       <p>
        Now we’ll implement them as expected:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Identity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">scalars</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">matrices</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scalar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">scalars</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">matrices</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> I; }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">scalars</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> I; }
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">matrices</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">scalars</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> times(m1.scalars(), m2.scalars());
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">matrices</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> times(m1.matrices(), m2.matrices());
    }
}</code></pre>
       <p>
        With these helper functions,
        <code>
         optimize()
        </code>
        can just separate the scalars and the matrices:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Identity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">optimize</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scalar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">optimize</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Matrix</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">optimize</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>; }
}

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MatrixExpression</span> </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> MatrixExpression <span class="hljs-title">optimize</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> times(scalars(), matrices());
    }
}</code></pre>
      </div>
     </div>
     <h2 id="next_summary">
      Next:
      <a href="../index.html#summary">
       Summary
      </a>
     </h2>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/16-recursive-data-types/matexpr/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:37:19 GMT -->
</html>
<!-- Handout delivered Sun Mar 06 2016 19:59:46 GMT-0500 (EST) -->
