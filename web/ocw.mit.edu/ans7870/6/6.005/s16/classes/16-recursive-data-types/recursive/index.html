<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/16-recursive-data-types/recursive/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:37:17 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 16, Part 1: Recursive Data Types
   </title>
   <link href="../../../web/handout-style.css" rel="stylesheet">
    <style>
     /* recursive data types styles */
.table-fields table td p { margin-bottom: 0; }
.table-fields table td input[type=text].form-control {
    width: 100% !important;
}
    </style>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_16_part_1_recursive_data_types">
      Reading 16, Part 1: Recursive Data Types
     </a>
    </li>
    <li>
     <a href="#recursive_functions">
      Recursive functions
     </a>
    </li>
    <li>
     <a href="#immutable_lists">
      Immutable lists
     </a>
    </li>
    <li>
     <a href="#recursive_datatype_definitions">
      Recursive datatype definitions
     </a>
    </li>
    <li>
     <a href="#functions_over_recursive_datatypes">
      Functions over recursive datatypes
     </a>
    </li>
    <li>
     <a href="#tuning_the_rep">
      Tuning the rep
     </a>
    </li>
    <li>
     <a href="#null_vs_empty">
      Null vs. empty
     </a>
    </li>
    <li>
     <a href="#declared_type_vs_actual_type">
      Declared type vs. actual type
     </a>
    </li>
    <li>
     <a href="#another_example_boolean_formulas">
      Another example: Boolean formulas
     </a>
    </li>
    <li>
     <a href="#summary">
      Summary
     </a>
    </li>
    <li>
     <a href="#next_writing_a_program_with_adts">
      Next: Writing a Program with ADTs
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_16_part_1_recursive_data_types">
    Reading 16, Part 1: Recursive Data Types
   </h1>
   <div data-outline="reading_16_part_1_recursive_data_types">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <h2 id="recursive_functions">
      Recursive functions
     </h2>
     <div data-outline="recursive_functions">
      <p>
       Before we introduce recursive datatypes — which have a recursive structure of both data and computation — take a minute to review
       <a href="../../10-recursion/index.html">
        recursive computations
       </a>
       .
      </p>
      <p>
       Just as a recursive function is defined in terms of itself, a
       <em>
        recursive datatype
       </em>
       is defined in terms of itself.
We’ll see the same need for
       <em>
        base
       </em>
       and
       <em>
        recursive
       </em>
       cases, which will now appear as different
       <em>
        variants
       </em>
       of the abstract type.
      </p>
     </div>
     <h2 id="immutable_lists">
      Immutable lists
     </h2>
     <div data-outline="immutable_lists">
      <p>
       We’ll start with a classic recursive datatype, the
       <em>
        immutable list
       </em>
       .
      </p>
      <p>
       Immutability is powerful not just because of its safety, but also because of the potential for sharing.
Sharing actually produces performance benefits: less memory consumed, less time spent copying.
Here we’re going to look at how to represent list data structures differently than in our familiar array lists or linked lists.
      </p>
      <p>
       Let’s define a data type for an immutable list,
       <code>
        ImList&lt;E&gt;
       </code>
       .
The data type has four fundamental operations:
      </p>
      <table class="table table-condensed no-markdown">
       <tbody>
        <tr>
         <th>
          empty: void → ImList
         </th>
         <td>
          // returns an empty list
         </td>
        </tr>
        <tr>
         <th style="white-space:nowrap">
          cons: E × ImList → ImList
         </th>
         <td>
          // returns a new list formed by adding an element to the front of another list
         </td>
        </tr>
        <tr>
         <th>
          first: ImList → E
         </th>
         <td>
          // returns the first element of a list, requires the list to be nonempty
         </td>
        </tr>
        <tr>
         <th>
          rest: ImList  → ImList
         </th>
         <td>
          // returns the list of all elements of this list except for the first, requires the list to be nonempty
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       These four operations have a long and distinguished pedigree.
They are fundamental to the list-processing languages
       <a href="http://en.wikipedia.org/wiki/Lisp_(programming_language)">
        Lisp
       </a>
       and
       <a href="http://en.wikipedia.org/wiki/Scheme_(programming_language)">
        Scheme
       </a>
       (where for historical reasons they are called nil,
       <a href="http://en.wikipedia.org/wiki/Cons">
        cons
       </a>
       ,
       <a href="http://en.wikipedia.org/wiki/CAR_and_CDR">
        car, and cdr
       </a>
       , respectively).
They are widely used in functional programming, where you can often find them called head and tail instead of
       <em>
        first
       </em>
       and
       <em>
        rest
       </em>
       .
      </p>
      <p>
       Before we design Java classes to implement this datatype, let’s get used to the operations a bit, using lists of integers.
We’ll write lists with square brackets, like [ 1, 2, 3 ], and we’ll write the operations as if they are mathematical functions.
Once we get to Java, the syntax will look different but the operations will have the same meaning.
      </p>
      <blockquote>
       <p>
        empty() = [ ]
       </p>
       <p>
        cons(0, empty() ) = [ 0 ]
       </p>
       <p>
        cons(0, cons(1, cons(2, empty() ) ) ) = [ 0, 1, 2 ]
       </p>
       <p>
        x ≡ cons(0, cons(1, cons(2, empty() ) ) )  = [ 0, 1, 2 ]
       </p>
       <p>
        first(x) = 0
       </p>
       <p>
        rest(x) = [ 1, 2 ]
       </p>
       <p>
        first(rest(x) ) = 1
       </p>
       <p>
        rest(rest(x) ) = [ 2 ]
       </p>
       <p>
        first(rest(rest(x) ) = 2
       </p>
       <p>
        rest(rest(rest(x) ) ) = [ ]
       </p>
      </blockquote>
      <p>
       The fundamental relationship between
       <em>
        first
       </em>
       ,
       <em>
        rest
       </em>
       , and
       <em>
        cons
       </em>
       is:
      </p>
      <blockquote>
       <p>
        first(cons(elt, lst) ) = elt
        <br>
         rest(cons(elt, lst) ) = lst
        </br>
       </p>
      </blockquote>
      <p>
       What
       <em>
        cons
       </em>
       puts together,
       <em>
        first
       </em>
       and
       <em>
        rest
       </em>
       peel back apart.
      </p>
      <h3 id="immutable_lists_in_java">
       Immutable lists in Java
      </h3>
      <div data-outline="immutable_lists_in_java">
       <p>
        To implement this datatype in Java, we’ll use an interface:
       </p>
       <div class="pull-left" style="min-width: 65%; margin-right: 20px;">
        <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> ImList&lt;E&gt; empty()</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> ImList&lt;E&gt; <span class="hljs-title">cons</span><span class="hljs-params">(E e)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">first</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> ImList&lt;E&gt; <span class="hljs-title">rest</span><span class="hljs-params">()</span></span>;
}</code></pre>
       </div>
       <div class="pull-margin">
        <p>
         This interface declares a
         <em>
          generic type
         </em>
         <code>
          ImList&lt;E&gt;
         </code>
         that can be instantiated for any type
         <code>
          E
         </code>
         :
         <code>
          ImList&lt;Integer&gt;
         </code>
         ,
         <code>
          ImList&lt;String&gt;
         </code>
         , etc.
The
         <code>
          E
         </code>
         in these declarations is a placeholder that the compiler will fill in when it checks our code for type safety.
        </p>
       </div>
       <div class="clearfix">
       </div>
       <p>
        And we’ll write two classes that implement this interface:
       </p>
       <ul>
        <li>
         <code>
          Empty
         </code>
         represents the result of the
         <em>
          empty
         </em>
         operation (an empty list)
        </li>
        <li>
         <code>
          Cons
         </code>
         represents the result of a
         <em>
          cons
         </em>
         operation (an element glued together with another list)
        </li>
       </ul>
       <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empty</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ImList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Empty</span><span class="hljs-params">()</span> </span>{
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> ImList&lt;E&gt; <span class="hljs-title">cons</span><span class="hljs-params">(E e)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cons&lt;&gt;(e, <span class="hljs-keyword">this</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> ImList&lt;E&gt; <span class="hljs-title">rest</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();
    }
}</code></pre>
       <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ImList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E e;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ImList&lt;E&gt; rest;

    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Cons</span><span class="hljs-params">(E e, ImList&lt;E&gt; rest)</span> </span>{
        <span class="hljs-keyword">this</span>.e = e;
        <span class="hljs-keyword">this</span>.rest = rest;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> ImList&lt;E&gt; <span class="hljs-title">cons</span><span class="hljs-params">(E e)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Cons&lt;&gt;(e, <span class="hljs-keyword">this</span>);
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">first</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> e;
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> ImList&lt;E&gt; <span class="hljs-title">rest</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> rest;
    }
}</code></pre>
       <p>
        So we have methods for
        <em>
         cons
        </em>
        ,
        <em>
         first
        </em>
        , and
        <em>
         rest
        </em>
        , but where is the fourth operation of our datatype,
        <em>
         empty
        </em>
        ?
       </p>
       <p>
        One way to implement
        <em>
         empty
        </em>
        is to have clients call the
        <code>
         Empty
        </code>
        class constructor to obtain empty lists.
This sacrifices representation independence — clients have to know about the
        <code>
         Empty
        </code>
        class!
       </p>
       <p>
        As we saw in
        <a href="../../14-interfaces/index.html">
         <em>
          Interfaces
         </em>
        </a>
        , a better way to do it is as a static factory method that takes no arguments and produces an instance of
        <code>
         Empty
        </code>
        .
We can put this static method in the
        <code>
         ImList
        </code>
        interface along with the other operations.
This choice was
        <em>
         not possible
        </em>
        in previous versions of Java, which is why we still write code like:
       </p>
       <pre><code class="language-java hljs">List&lt;String&gt; z = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</code></pre>
       <p>
        Perhaps someday Java will offer a
        <code>
         List.empty()
        </code>
        method to obtain a new empty
        <code>
         List
        </code>
        , but not yet.
       </p>
       <p>
        We will go ahead and update our
        <code>
         ImList
        </code>
        interface with the static
        <code>
         empty
        </code>
        method:
       </p>
       <div class="pull-left" style="min-width: 65%; margin-right: 20px;">
        <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">ImList&lt;E&gt; <span class="hljs-title">empty</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Empty&lt;&gt;();
    }
    <span class="hljs-function"><span class="hljs-keyword">public</span> ImList&lt;E&gt; <span class="hljs-title">cons</span><span class="hljs-params">(E e)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">first</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">public</span> ImList&lt;E&gt; <span class="hljs-title">rest</span><span class="hljs-params">()</span></span>;
}</code></pre>
       </div>
       <div class="pull-margin">
        <p>
         The signature for
         <code>
          empty
         </code>
         uses a new bit of generic type syntax.
The
         <code>
          E
         </code>
         in
         <code>
          ImList&lt;E&gt;
         </code>
         is a placeholder for the type of elements in an instance of
         <code>
          ImList
         </code>
         , but
         <code>
          empty
         </code>
         is a static method: it cannot see instance variables or methods, and it also cannot see the instance type parameter.
You can read the declaration of
         <code>
          empty
         </code>
         as: “for any
         <code>
          E
         </code>
         ,
         <code>
          empty()
         </code>
         returns an
         <code>
          ImList&lt;E&gt;
         </code>
         .”
        </p>
       </div>
       <div class="clearfix">
       </div>
       <p>
        Now that we have all the operations, here’s some actual Java code that parallels the abstract examples we wrote earlier.
Hover or tap on each row in the table to update the snapshot diagram:
       </p>
       <div class="panel panel-figure inline-figure hover-figure no-markdown col-sm-12 col-lg-10" data-attr="src" data-selector="#imlist-examples tbody tr" data-target="img" data-template="../figures/imlist%7bindex%7d.html">
        <img src="../figures/imlist0.png"/>
       </div>
       <div id="imlist-examples">
        <table class="table">
         <thead>
          <tr>
           <th>
            Java syntax
           </th>
           <th>
            Functional syntax
           </th>
           <th>
            Result
           </th>
          </tr>
         </thead>
         <tbody>
          <tr class="highlighted">
           <td>
            <code>
             ImList&lt;Integer&gt; nil = ImList.empty();
            </code>
           </td>
           <td>
            <em>
             nil = empty()
            </em>
           </td>
           <td>
            [ ]
           </td>
          </tr>
          <tr>
           <td>
            <code>
             nil.cons(0)
            </code>
           </td>
           <td>
            <em>
             cons(0, nil)
            </em>
           </td>
           <td>
            [ 0 ]
           </td>
          </tr>
          <tr>
           <td>
            <code>
             nil.cons(2).cons(1).cons(0)
            </code>
           </td>
           <td>
            <em>
             cons(0, cons(1, cons(2, nil)))
            </em>
           </td>
           <td>
            [ 0, 1, 2 ]
           </td>
          </tr>
          <tr>
           <td>
            <code>
             ImList&lt;Integer&gt; x = nil.cons(2).cons(1).cons(0);
            </code>
           </td>
           <td>
            <em>
             x = cons(0, cons(1, cons(2, nil)))
            </em>
           </td>
           <td>
            [ 0, 1, 2 ]
           </td>
          </tr>
          <tr>
           <td>
            <code>
             x.first()
            </code>
           </td>
           <td>
            <em>
             first(x)
            </em>
           </td>
           <td>
            0
           </td>
          </tr>
          <tr>
           <td>
            <code>
             x.rest()
            </code>
           </td>
           <td>
            <em>
             rest(x)
            </em>
           </td>
           <td>
            [ 1, 2 ]
           </td>
          </tr>
          <tr>
           <td>
            <code>
             x.rest().first()
            </code>
           </td>
           <td>
            <em>
             first(rest(x))
            </em>
           </td>
           <td>
            1
           </td>
          </tr>
          <tr>
           <td>
            <code>
             x.rest().rest()
            </code>
           </td>
           <td>
            <em>
             rest(rest(x))
            </em>
           </td>
           <td>
            [ 2 ]
           </td>
          </tr>
          <tr>
           <td>
            <code>
             x.rest().rest().first()
            </code>
           </td>
           <td>
            <em>
             first(rest(rest(x)))
            </em>
           </td>
           <td>
            2
           </td>
          </tr>
          <tr>
           <td>
            <code>
             x.rest().rest().rest()
            </code>
           </td>
           <td>
            <em>
             rest(rest(rest(x)))
            </em>
           </td>
           <td>
            [ ]
           </td>
          </tr>
          <tr>
           <td>
            <code>
             ImList&lt;Integer&gt; y = x.rest().cons(4);
            </code>
           </td>
           <td>
            <em>
             y = cons(4, rest(x))
            </em>
           </td>
           <td>
            [ 4, 1, 2 ]
           </td>
          </tr>
         </tbody>
        </table>
       </div>
       <p>
        The key thing to note here is the
        <em>
         sharing of structure
        </em>
        that immutable list provides.
In the last example above,
        <code>
         x
        </code>
        and
        <code>
         y
        </code>
        are sharing their representation of the sublist [ 1, 2 ].
       </p>
      </div>
      <h3 id="two_classes_implementing_one_interface">
       Two classes implementing one interface
      </h3>
      <div data-outline="two_classes_implementing_one_interface">
       <p>
        Note that this design is different from what we have seen with
        <code>
         List
        </code>
        ,
        <code>
         ArrayList
        </code>
        , and
        <code>
         LinkedList
        </code>
        .
        <code>
         List
        </code>
        is an abstract data type and
        <code>
         ArrayList
        </code>
        and
        <code>
         LinkedList
        </code>
        are two
        <em>
         alternative
        </em>
        concrete representations for that datatype.
       </p>
       <p>
        For
        <code>
         ImList
        </code>
        , the two implementations
        <code>
         Empty
        </code>
        and
        <code>
         Cons
        </code>
        <em>
         cooperate
        </em>
        in order to implement the datatype — you need them both.
       </p>
      </div>
     </div>
     <h2 id="recursive_datatype_definitions">
      Recursive datatype definitions
     </h2>
     <div data-outline="recursive_datatype_definitions">
      <p>
       The abstract data type
       <code>
        ImList
       </code>
       , and its two concrete classes
       <code>
        Empty
       </code>
       and
       <code>
        Cons
       </code>
       , form a
       <em>
        recursive
       </em>
       data type.
       <code>
        Cons
       </code>
       is an implementation of
       <code>
        ImList
       </code>
       , but it also uses
       <code>
        ImList
       </code>
       inside its own rep (for the
       <code>
        rest
       </code>
       field), so it recursively requires an implementation of
       <code>
        ImList
       </code>
       in order to successfully implement its contract.
      </p>
      <p>
       To make this fact clearly visible, we’ll write a
       <strong>
        datatype definition
       </strong>
       :
      </p>
      <pre><code class="hljs xml">ImList<span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span> = Empty + Cons(first:E, rest:ImList)
</code></pre>
      <p>
       This is a recursive definition of
       <code>
        ImList
       </code>
       as a set of values.
Read it like this: the set
       <code>
        ImList
       </code>
       consists of values formed in two ways: either by the
       <code>
        Empty
       </code>
       constructor, or by applying the
       <code>
        Cons
       </code>
       constructor to an element and an
       <code>
        ImList
       </code>
       .
The recursive nature of the datatype becomes far more visible when written this way.
      </p>
      <p>
       We can also write
       <code>
        ImList
       </code>
       values as terms or expressions using this definition, e.g.:
      </p>
      <pre><code class="hljs php">Cons(<span class="hljs-number">0</span>, Cons(<span class="hljs-number">1</span>, Cons(<span class="hljs-number">2</span>, <span class="hljs-keyword">Empty</span>)))
</code></pre>
      <p>
       Formally, a datatype definition has:
      </p>
      <ul>
       <li>
        an
        <strong>
         abstract datatype
        </strong>
        on the left, defined by its
        <strong>
         representation
        </strong>
        (or
        <strong>
         concrete datatype
        </strong>
        ) on the right
       </li>
       <li>
        the representation consists of
        <strong>
         variants
        </strong>
        of the datatype separated by
        <strong>
         +
        </strong>
       </li>
       <li>
        each variant is a constructor with zero or more named (and typed) arguments
       </li>
      </ul>
      <p>
       Another example is a binary tree:
      </p>
      <pre><code class="hljs xml">Tree<span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span> = Empty + Node(e:E, left:Tree<span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span>, right:Tree<span class="hljs-tag">&lt;<span class="hljs-name">E</span>&gt;</span>)
</code></pre>
      <p>
       We’ll see more examples below.
      </p>
     </div>
     <h2 id="functions_over_recursive_datatypes">
      Functions over recursive datatypes
     </h2>
     <div data-outline="functions_over_recursive_datatypes">
      <p>
       This way of thinking about datatypes — as a recursive definition of an abstract datatype with concrete variants — is appealing not only because it can handle recursive and unbounded structures like lists and trees, but also because it provides a convenient way to describe operations over the datatype, as functions with one case per variant.
      </p>
      <p>
       For example, consider the size of the list, which is certainly an operation we’ll want in
       <code>
        ImList
       </code>
       .
We can define it like this:
      </p>
      <p>
       <strong>
        size : ImList → int
       </strong>
       // returns the size of the list
      </p>
      <p>
       and then fully specify its meaning by defining
       <em>
        size
       </em>
       for each variant of
       <code>
        ImList
       </code>
       :
      </p>
      <blockquote>
       <p>
        size(Empty) = 0
        <br>
         size(Cons(first: E, rest: ImList)) = 1 + size(rest)
        </br>
       </p>
      </blockquote>
      <p>
       This function is recursive.
We can think about the execution of
       <em>
        size
       </em>
       on a particular list as a series of reduction steps:
      </p>
      <blockquote>
       <p>
        size(Cons (0, Cons (1, Empty)))
        <br>
         = 1 + size(Cons (1, Empty))
         <br>
          = 1 + (1 + size(Empty))
          <br>
           = 1 + (1 + 0)
           <br>
            = 1 + 1
            <br>
             = 2
            </br>
           </br>
          </br>
         </br>
        </br>
       </p>
      </blockquote>
      <p>
       And the cases from the definition can be translated directly into Java as methods in
       <code>
        ImList
       </code>
       ,
       <code>
        Empty
       </code>
       , and
       <code>
        Cons
       </code>
       :
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ImList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span></span>;
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Empty</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ImList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }
}

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ImList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{
    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + rest.size(); }
}</code></pre>
      <p>
       This pattern of implementing an operation over a recursive datatype by
      </p>
      <ul>
       <li>
        <strong>
         declaring
        </strong>
        the operation in the abstract datatype interface
       </li>
       <li>
        <strong>
         implementing
        </strong>
        the operation (recursively) in each concrete variant
       </li>
      </ul>
      <p>
       is a very common and practical design pattern.
It sometimes goes by the unhelpful name
       <em>
        interpreter pattern
       </em>
       .
      </p>
      <p>
       Let’s try a few more examples:
      </p>
      <p>
       <strong>
        isEmpty : ImList → boolean
       </strong>
      </p>
      <blockquote>
       <p>
        isEmpty(Empty) = true
        <br>
         isEmpty(Cons(first: E, rest: ImList)) = false
        </br>
       </p>
      </blockquote>
      <p>
       <strong>
        contains : ImList × E → boolean
       </strong>
      </p>
      <blockquote>
       <p>
        contains(Empty, e: E) = false
        <br>
         contains(Cons(first: E, rest: ImList), e: E) = (first = e) ∨ contains(rest, e)
        </br>
       </p>
      </blockquote>
      <p>
       <strong>
        get: ImList × int → E
       </strong>
      </p>
      <blockquote>
       <p>
        get(Empty, e: E) = undefined
        <br>
         get(Cons(first: E, rest: ImList), n) = if n=0 then first else get(rest, n-1)
        </br>
       </p>
      </blockquote>
      <p>
       <strong>
        append: ImList × ImList → ImList
       </strong>
      </p>
      <blockquote>
       <p>
        append(Empty, list2: ImList) = list2
        <br>
         append(Cons(first: E, rest: ImList), list2: ImList) = cons(first, append(rest, list2))
        </br>
       </p>
      </blockquote>
      <p>
       <strong>
        reverse: ImList → ImList
       </strong>
      </p>
      <blockquote>
       <p>
        reverse(Empty) = empty()
        <br>
         reverse(Cons(first: E, rest: ImList)) = append(reverse(rest), cons(first, empty())
        </br>
       </p>
      </blockquote>
      <p>
       For
       <em>
        reverse
       </em>
       , it turns out that the recursive definition produces a pretty bad implementation in Java, with performance that’s quadratic in the length of the list you’re reversing.
We could rewrite it using an iterative approach if needed.
      </p>
     </div>
     <h2 id="tuning_the_rep">
      Tuning the rep
     </h2>
     <div data-outline="tuning_the_rep">
      <p>
       Getting the size of a list is a common operation.
Right now our implementation of
       <code>
        size()
       </code>
       takes
       <em>
        O(n)
       </em>
       time, where
       <em>
        n
       </em>
       is the length of the list — that’s linear in the number of list items.
We can make it better with a simple change to the rep of the list that caches the size the first time we compute it, so that subsequently it costs only
       <em>
        O(1)
       </em>
       time — constant time, independent of the number of list items — to get:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cons</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ImList</span>&lt;<span class="hljs-title">E</span>&gt; </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E e;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ImList&lt;E&gt; rest;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// rep invariant:</span>
    <span class="hljs-comment">//   e != null, rest != null, size &gt;= 0</span>
    <span class="hljs-comment">//   size &gt; 0 implies size == 1+rest.size()</span>

    <span class="hljs-comment">// ...</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>{ 
        <span class="hljs-keyword">if</span> (size == <span class="hljs-number">0</span>) size = <span class="hljs-number">1</span> + rest.size();
        <span class="hljs-keyword">return</span> size;
    }
}</code></pre>
      <p>
       Note that we’re using the special value 0 (which can never be the size of a
       <code>
        Cons
       </code>
       ) to indicate that we haven’t computed the size yet.
Note also that this change introduces a new clause to the rep invariant, relating the
       <code>
        size
       </code>
       field to the
       <code>
        rest
       </code>
       field.
      </p>
      <p>
       There’s something interesting happening here: this is an immutable datatype, and yet it has a mutable rep.
It’s modifying its own size field, in this case to cache the result of an expensive operation.
This is an example of a
       <strong>
        beneficent mutation
       </strong>
       , a state change that doesn’t change the abstract value represented by the object, so the type is still immutable.
      </p>
      <h3 id="rep_independence_and_rep_exposure_revisited">
       Rep independence and rep exposure revisited
      </h3>
      <div data-outline="rep_independence_and_rep_exposure_revisited">
       <p>
        Does our Java implementation of
        <code>
         ImList
        </code>
        still have rep independence?
We’ve concealed the
        <code>
         Empty
        </code>
        contructor behind the static method
        <code>
         ImList.empty()
        </code>
        , and clients should never need to use the
        <code>
         Empty
        </code>
        or
        <code>
         Cons
        </code>
        constructors directly.
We can hide them further by making them package-private (declared with neither the
        <code>
         public
        </code>
        nor
        <code>
         private
        </code>
        keyword) so that classes outside of
        <code>
         ImList
        </code>
        ’s package cannot see or use them.
       </p>
       <p>
        We have a great deal of freedom to change our implementation — indeed, we just added a
        <code>
         size
        </code>
        field to the internal rep of
        <code>
         Cons
        </code>
        .
We could even have an extra array in there to make
        <code>
         get()
        </code>
        run fast!
This might get expensive in space, however, but we are free to make those tradeoffs.
       </p>
       <p>
        Is there rep exposure because
        <code>
         Cons.rest()
        </code>
        returns a reference to its internal list?
Could a clumsy client add elements to the rest of the list?
If so, this would threaten two of
        <code>
         Cons
        </code>
        ’s invariants: that it’s immutable, and that the cached size is always correct.
But there’s no risk of rep exposure, because the internal list is immutable.
Nobody can threaten the rep invariant of
        <code>
         Cons
        </code>
        .
       </p>
      </div>
     </div>
     <h2 id="null_vs_empty">
      Null vs. empty
     </h2>
     <div data-outline="null_vs_empty">
      <p>
       It might be tempting to get rid of the
       <code>
        Empty
       </code>
       class and just use
       <code>
        null
       </code>
       instead.
Resist that temptation.
      </p>
      <p>
       Using an object, rather than a null reference, to signal the base case or endpoint of a data structure is an example of a design pattern called
       <em>
        sentinel objects
       </em>
       .
The enormous advantage that a sentinel object provides is that it acts like an object in the datatype, so you can call methods on it.
So we can call the
       <code>
        size()
       </code>
       method even on an empty list.
If empty lists were represented by
       <code>
        null
       </code>
       , then we wouldn’t be able to do that, and as a consequence our code would be full of tests like:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">if</span> (lst != <span class="hljs-keyword">null</span>) n = lst.size();</code></pre>
      <p>
       which clutter the code, obscure its meaning, and are easy to forget.
Better the much simpler
      </p>
      <pre><code class="language-java hljs">n = lst.size();</code></pre>
      <p>
       which will always work, including when an empty
       <code>
        lst
       </code>
       refers to an
       <code>
        Empty
       </code>
       object.
      </p>
      <p>
       Keep
       <code>
        null
       </code>
       s out of your data structures, and your life will be happier.
      </p>
     </div>
     <h2 id="declared_type_vs_actual_type">
      Declared type vs. actual type
     </h2>
     <div data-outline="declared_type_vs_actual_type">
      <p>
       Now that we’re using interfaces and classes, it’s worth taking a moment to reinforce an important point about how Java’s type-checking works.
In fact every statically-checked object-oriented language works this way.
      </p>
      <p>
       There are two worlds in type checking:
       <strong>
        compile time
       </strong>
       before the program runs, and run time when the program is executing.
      </p>
      <p>
       At compile time, every variable has a
       <strong>
        declared type
       </strong>
       , stated in its declaration.
The compiler uses the declared types of variables (and method return values) to deduce declared types for every expression in the program.
      </p>
      <p>
       At run time, every object has an
       <strong>
        actual type
       </strong>
       , imbued in it by the constructor that created the object.
For example,
       <code>
        new String()
       </code>
       makes an object whose actual type is
       <code>
        String
       </code>
       .
       <code>
        new Empty()
       </code>
       makes an object whose actual type is
       <code>
        Empty
       </code>
       .
       <code>
        new ImList()
       </code>
       is forbidden by Java, because
       <code>
        ImList
       </code>
       is an interface — it has no object values of its own, and no constructors.
      </p>
     </div>
     <h2 id="another_example_boolean_formulas">
      Another example: Boolean formulas
     </h2>
     <div data-outline="another_example_boolean_formulas">
      <p>
       Another useful sort of recursive datatype in computer science is for Boolean formulas.
For instance, here’s a formula of propositional logic:
      </p>
      <blockquote>
       <p>
        (P
        <a href="https://en.wikipedia.org/wiki/Logical_disjunction">
         ∨
        </a>
        Q)
        <a href="https://en.wikipedia.org/wiki/Logical_conjunction">
         ∧
        </a>
        (
        <a href="https://en.wikipedia.org/wiki/Logical_negation">
         ¬
        </a>
        P
        <a href="https://en.wikipedia.org/wiki/Logical_disjunction">
         ∨
        </a>
        R)
       </p>
      </blockquote>
      <p>
       which means “either P or Q is true,
       <em>
        and
       </em>
       either P is false or R is true.”
      </p>
      <p>
       We can give a datatype definition suitable for representing all formulas of propositional logic.
      </p>
      <pre><code class="hljs php">Formula = Variable(name:String)
          + Not(formula:Formula)
          + <span class="hljs-keyword">And</span>(left:Formula, right:Formula)
          + <span class="hljs-keyword">Or</span>(left:Formula, right:Formula)
</code></pre>
      <p>
       <em>
        (P ∨ Q) ∧ (¬P ∨ R)
       </em>
       would be
      </p>
      <pre><code class="hljs php"><span class="hljs-keyword">And</span>( <span class="hljs-keyword">Or</span>(Variable(<span class="hljs-string">"P"</span>), Variable(<span class="hljs-string">"Q"</span>)),
     <span class="hljs-keyword">Or</span>(Not(Variable(<span class="hljs-string">"P"</span>)), Variable(<span class="hljs-string">"R"</span>)) )
</code></pre>
      <p>
       A key operation for Boolean formulas is testing whether they are
       <em>
        satisfiable
       </em>
       , that is, whether some assignment of true/false values to the variables leads the formula to evaluate to true.
There is a simple but slow algorithm for checking satisfiability:
      </p>
      <ol>
       <li>
        <p>
         Extract the set of variables from the formula.
         <br>
          We’ve already implemented this with the
          <strong>
           variables
          </strong>
          operation.
         </br>
        </p>
       </li>
       <li>
        <p>
         Try all possible assignments of true/false values to those variables.
         <br>
          We can represent an assignment with an
          <code>
           Environment
          </code>
          : a list of variables and their values.
We could use
          <code>
           ImList
          </code>
          to implement the
          <code>
           Environment
          </code>
          , or develop an immutable map type.
         </br>
        </p>
       </li>
       <li>
        <p>
         Evaluate the formula for each environment.
         <br>
          For this, we’ll define
          <strong>
           evaluate : Formula × Environment → Boolean
          </strong>
          .
         </br>
        </p>
       </li>
       <li>
        <p>
         Return the first environment in which the formula evaluates to true.
        </p>
       </li>
      </ol>
      <p>
       Defining these pieces and putting them together into a
       <strong>
        satisfiable : Formula → Boolean
       </strong>
       function is an exercise for another time.
      </p>
      <h3 id="backtracking_search_with_immutability">
       Backtracking search with immutability
      </h3>
      <div data-outline="backtracking_search_with_immutability">
       <p>
        We started out this part of the reading with immutable lists, which are a representation that permits a lot of sharing between different list instances.
Sharing of a particular kind, though: only the ends of lists can actually be shared.
If two lists are identical at the beginning but then diverge from each other, they have to be stored separately.
(Why?)
       </p>
       <p>
        It turns out that backtracking search is a great application for these lists, and here’s why.
A search through a space (like the space of assignments to a set of Boolean variables) generally proceeds by making one choice after another, and when a choice leads to a dead end, you backtrack.
       </p>
       <p>
        Mutable data structures are typically not a good approach for backtracking.
If you use a mutable
        <code>
         Map
        </code>
        , say, to keep track of the current variable bindings you’re trying, then you have to undo those bindings every time you backtrack.
That’s error-prone and painful compared to what you do with immutable maps — when you backtrack, you just throw the map away!
       </p>
       <p>
        But immutable data structures with no sharing aren’t a great idea either, because the space you need to keep track of where you are (in the case of the satisfiability problem, the environment) will grow quadratically if you have to make a complete copy every time you take a new step.
You need to hold on to all the previous environments on your path, in case you need to back up.
       </p>
       <p>
        Immutable lists have the nice property that each step taken on the path can share all the information from the previous steps, just by adding to the front of the list.
When you have to backtrack, you stop using the current step’s state — but you still have references to the previous step’s state.
       </p>
       <p>
        Finally, a search that uses immutable data structures is immediately ready to be parallelized.
You can delegate multiple processors to search multiple paths at once, without having to deal with the problem that they’ll step on each other in a shared mutable data structure.
We’ll talk about this more when we get to concurrency.
       </p>
      </div>
     </div>
     <h2 id="summary">
      Summary
     </h2>
     <div data-outline="summary">
      <p>
       In addition to the big idea of
       <strong>
        recursive datatypes
       </strong>
       , we saw in this reading:
      </p>
      <ul>
       <li>
        <strong>
         datatype definitions
        </strong>
        : a powerful way to think about abstract types, particularly recursive ones
       </li>
       <li>
        <strong>
         functions over recursive datatypes
        </strong>
        : declared in the specification for the type, and implemented with one case per concrete variant
       </li>
       <li>
        immutable lists: a classic, canonical example of an immutable datatype
       </li>
      </ul>
      <p>
       As always, we ask how these ideas make our code
       <strong>
        safer from bugs
       </strong>
       ,
       <strong>
        easier to understand
       </strong>
       , and more
       <strong>
        ready for change
       </strong>
       .
Look again at the
       <a href="#functions_over_recursive_datatypes">
        definition and implementation of
        <code>
         size()
        </code>
        in
        <code>
         ImList
        </code>
       </a>
       .
The definition is little more than the mathematical definition of size.
The code is little more than the definition, with some semicolons to placate the compiler.
      </p>
      <p>
       If we examine the definitions for further methods —
       <code>
        isEmpty
       </code>
       ,
       <code>
        contains
       </code>
       , etc. — in each case we see a safe, easy-to-read implementation waiting to be coded.
Since we’ve taken the time to specify these operations, if we avoid rep exposure and maintain rep independence, we know our code is ready for change: different clients will be able to reuse our datatype, and we will be able to update the implementation without breaking them.
      </p>
     </div>
     <h2 id="next_writing_a_program_with_adts">
      Next:
      <a href="../matexpr/index.html">
       Writing a Program with ADTs
      </a>
     </h2>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/16-recursive-data-types/recursive/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:37:19 GMT -->
</html>
<!-- Handout delivered Sun Mar 06 2016 19:59:47 GMT-0500 (EST) -->
