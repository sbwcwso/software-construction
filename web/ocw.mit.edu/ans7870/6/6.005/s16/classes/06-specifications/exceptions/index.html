<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/06-specifications/exceptions/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:37:15 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 6, Part 2: Exceptions
   </title>
   <link href="../../../web/handout-style.css" rel="stylesheet">
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_6_part_2_exceptions">
      Reading 6, Part 2: Exceptions
     </a>
    </li>
    <li>
     <a href="#exceptions_for_signaling_bugs">
      Exceptions for signaling bugs
     </a>
    </li>
    <li>
     <a href="#exceptions_for_special_results">
      Exceptions for special results
     </a>
    </li>
    <li>
     <a href="#checked_and_unchecked_exceptions">
      Checked and unchecked exceptions
     </a>
    </li>
    <li>
     <a href="#throwable_hierarchy">
      Throwable hierarchy
     </a>
    </li>
    <li>
     <a href="#exception_design_considerations">
      Exception design considerations
     </a>
    </li>
    <li>
     <a href="#abuse_of_exceptions">
      Abuse of exceptions
     </a>
    </li>
    <li>
     <a href="#next_summary">
      Next: Summary
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_6_part_2_exceptions">
    Reading 6, Part 2: Exceptions
   </h1>
   <div data-outline="reading_6_part_2_exceptions">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <p>
      Now that we’re writing specifications and thinking about how clients will use our methods, let’s discuss how to handle
      <em>
       exceptional
      </em>
      cases in a way that is safe from bugs and easy to understand.
     </p>
     <p>
      A method’s
      <em>
       signature
      </em>
      — its name, parameter types, return type — is a core part of its specification, and the signature may also include
      <em>
       exceptions
      </em>
      that the method may trigger.
     </p>
     <h2 id="exceptions_for_signaling_bugs">
      Exceptions for signaling bugs
     </h2>
     <div data-outline="exceptions_for_signaling_bugs">
      <p>
       You’ve probably already seen some exceptions in your Java programming so far, such as
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/lang/ArrayIndexOutOfBoundsException.html">
        <code>
         ArrayIndex­OutOfBounds­Exception
        </code>
       </a>
       (thrown when an array index
       <code>
        foo[i]
       </code>
       is outside the valid range for the array
       <code>
        foo
       </code>
       ) or
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/lang/NullPointerException.html">
        <code>
         Null­Pointer­Exception
        </code>
       </a>
       (thrown when trying to call a method on a
       <code>
        null
       </code>
       object reference).
These exceptions generally indicate
       <strong>
        bugs
       </strong>
       in your code, and the information displayed by Java when the exception is thrown can help you find and fix the bug.
      </p>
      <p>
       <code>
        ArrayIndex­OutOfBounds-
       </code>
       and
       <code>
        Null­Pointer­Exception
       </code>
       are probably the most common exceptions of this sort.
Other examples include:
      </p>
      <ul>
       <li>
        <a href="http://docs.oracle.com/javase/8/docs/api/?java/lang/ArithmeticException.html">
         <code>
          ArithmeticException
         </code>
        </a>
        , thrown for arithmetic errors like integer division by zero.
       </li>
       <li>
        <a href="http://docs.oracle.com/javase/8/docs/api/?java/lang/NumberFormatException.html">
         <code>
          NumberFormatException
         </code>
        </a>
        , thrown by methods like
        <code>
         Integer.parseInt
        </code>
        if you pass in a string that cannot be parsed into an integer.
       </li>
      </ul>
     </div>
     <h2 id="exceptions_for_special_results">
      Exceptions for special results
     </h2>
     <div data-outline="exceptions_for_special_results">
      <p>
       Exceptions are not just for signaling bugs.
They can be used to improve the structure of code that involves procedures with special results.
      </p>
      <p>
       An unfortunately common way to handle special results is to return special values.
Lookup operations in the Java library are often designed like this: you get an index of -1 when expecting a positive integer, or a
       <code>
        null
       </code>
       reference when expecting an object.
This approach is OK if used sparingly, but it has two problems.
First, it’s tedious to check the return value.
Second, it’s easy to forget to do it.
(We’ll see that by using exceptions you can get help from the compiler in this.)
      </p>
      <p>
       Also, it’s not always easy to find a ‘special value’.
Suppose we have a
       <code>
        BirthdayBook
       </code>
       class with a lookup method.
Here’s one possible method signature:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BirthdayBook</span> </span>{
    <span class="hljs-function">LocalDate <span class="hljs-title">lookup</span><span class="hljs-params">(String name)</span> </span>{ ... }
}</code></pre>
      <p>
       (
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/time/LocalDate.html">
        <code>
         LocalDate
        </code>
       </a>
       is part of the Java API.)
      </p>
      <p>
       What should the method do if the birthday book doesn’t have an entry for the person whose name is given?
Well, we could return some special date that is not going to be used as a real date.
Bad programmers have been doing this for decades; they would return 9/9/99, for example, since it was
       <em>
        obvious
       </em>
       that no program written in 1960 would still be running at the end of the century.
(
       <a href="http://en.wikipedia.org/wiki/Year_2000_problem">
        They were wrong, by the way.
       </a>
       )
      </p>
      <p>
       Here’s a better approach.
The method throws an exception:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-function">LocalDate <span class="hljs-title">lookup</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NotFoundException </span>{
    ...
    <span class="hljs-keyword">if</span> ( ...not found... )
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NotFoundException();
    ...</code></pre>
      <p>
       and the caller handles the exception with a
       <code>
        catch
       </code>
       clause.
For example:
      </p>
      <pre><code class="language-java hljs">BirthdayBook birthdays = ...
<span class="hljs-keyword">try</span> {
    LocalDate birthdate = birthdays.lookup(<span class="hljs-string">"Alyssa"</span>);
    <span class="hljs-comment">// we know Alyssa's birthday</span>
} <span class="hljs-keyword">catch</span> (NotFoundException nfe) {
    <span class="hljs-comment">// her birthday was not in the birthday book</span>
}</code></pre>
      <p>
       Now there’s no need for any special value, nor the checking associated with it.
      </p>
      <div class="handout-solo alert alert-warning">
       <p>
        Read:
        <strong>
         <a class="alert-link" href="http://docs.oracle.com/javase/tutorial/essential/exceptions/index.html">
          Exceptions
         </a>
        </strong>
        in the Java Tutorials.
       </p>
      </div>
     </div>
     <h2 id="checked_and_unchecked_exceptions">
      Checked and unchecked exceptions
     </h2>
     <div data-outline="checked_and_unchecked_exceptions">
      <p>
       We’ve seen two different purposes for exceptions: special results and bug detection.
As a general rule, you’ll want to use checked exceptions to signal special results and unchecked exceptions to signal bugs.
In a
       <a href="#exception_design_considerations">
        later section
       </a>
       , we’ll refine this a bit.
      </p>
      <p>
       Some terminology:
       <em>
        checked
       </em>
       exceptions are called that because they are checked by the compiler:
      </p>
      <ul>
       <li>
        If a method might throw a checked exception, the possibility must be declared in its signature.
        <code>
         Not­Found­Exception
        </code>
        would be a checked exception, and that’s why the signature ends
        <code>
         throws Not­Found­Exception
        </code>
        .
       </li>
       <li>
        If a method calls another method that may throw a checked exception, it must either handle it, or declare the exception itself, since if it isn’t caught locally it will be propagated up to callers.
       </li>
      </ul>
      <p>
       So if you call
       <code>
        BirthdayBook
       </code>
       ’s
       <code>
        lookup
       </code>
       method and forget to handle the
       <code>
        Not­Found­Exception
       </code>
       , the compiler will reject your code.
This is very useful, because it ensures that exceptions that are expected to occur will be handled.
      </p>
      <p>
       <em>
        Unchecked
       </em>
       exceptions, in contrast, are used to signal bugs.
These exceptions are not expected to be handled by the code except perhaps at the top level.
We wouldn’t want every method up the call chain to have to declare that it (might) throw all the kinds of bug-related exceptions that can happen at lower call levels: index out of bounds, null pointers, illegal arguments, assertion failures, etc.
      </p>
      <p>
       As a result, for an unchecked exception the compiler will not check for
       <code>
        try
       </code>
       -
       <code>
        catch
       </code>
       or a
       <code>
        throws
       </code>
       declaration.
Java still allows you to write a
       <code>
        throws
       </code>
       clause for an unchecked exception as part of a method signature, but this has no effect, and is thus a bit funny, and we don’t recommend doing it.
      </p>
      <p>
       All exceptions may have a message associated with them.
If not provided in the constructor, the reference to the message string is
       <code>
        null
       </code>
       .
      </p>
     </div>
     <h2 id="throwable_hierarchy">
      Throwable hierarchy
     </h2>
     <div data-outline="throwable_hierarchy">
      <p>
       To understand how Java decides whether an exception is checked or unchecked, let’s look at the class hierarchy for Java exceptions.
      </p>
      <div class="panel panel-figure pull-right pull-margin">
       <div class="panel-body">
        <img src="../figures/throwable.png" width="300"/>
       </div>
      </div>
      <p>
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/lang/Throwable.html">
        <code>
         Throwable
        </code>
       </a>
       is the class of objects that can be thrown or caught.
       <code>
        Throwable
       </code>
       ’s implementation records a stack trace at the point where the exception was thrown, along with an optional string describing the exception.
Any object used in a
       <code>
        throw
       </code>
       or
       <code>
        catch
       </code>
       statement, or declared in the
       <code>
        throws
       </code>
       clause of a method, must be a subclass of
       <code>
        Throwable
       </code>
       .
      </p>
      <p>
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/lang/Error.html">
        <code>
         Error
        </code>
       </a>
       is a subclass of
       <code>
        Throwable
       </code>
       that is reserved for errors produced by the Java runtime system, such as
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/lang/StackOverflowError.html">
        <code>
         StackOverflow­Error
        </code>
       </a>
       and
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/lang/OutOfMemoryError.html">
        <code>
         OutOfMemory­Error
        </code>
       </a>
       .
For some reason
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/lang/AssertionError.html">
        <code>
         Assertion­Error
        </code>
       </a>
       also extends
       <code>
        Error
       </code>
       , even though it indicates a bug in user code, not in the runtime.
Errors should be considered unrecoverable, and are generally not caught.
      </p>
      <p>
       Here’s how Java distinguishes between checked and unchecked exceptions:
      </p>
      <ul>
       <li>
        <code>
         RuntimeException
        </code>
        ,
        <code>
         Error
        </code>
        , and their subclasses are
        <strong>
         unchecked
        </strong>
        exceptions.
The compiler doesn’t require them to be declared in the
        <code>
         throws
        </code>
        clause of a method that throws them, and doesn’t require them to be caught or declared by a caller of such a method.
       </li>
       <li>
        All other throwables —
        <code>
         Throwable
        </code>
        ,
        <code>
         Exception
        </code>
        , and all of their subclasses except for those of the
        <code>
         RuntimeException
        </code>
        and
        <code>
         Error
        </code>
        lineage — are
        <strong>
         checked
        </strong>
        exceptions.
The compiler requires these exceptions to be caught or declared when it’s possible for them to be thrown.
       </li>
      </ul>
      <p>
       When you define your own exceptions, you should either subclass
       <code>
        RuntimeException
       </code>
       (to make it an unchecked exception) or
       <code>
        Exception
       </code>
       (to make it checked).
Programmers generally don’t subclass
       <code>
        Error
       </code>
       or
       <code>
        Throwable
       </code>
       , because these are reserved by Java itself.
      </p>
     </div>
     <h2 id="exception_design_considerations">
      Exception design considerations
     </h2>
     <div data-outline="exception_design_considerations">
      <p>
       The rule we have given — use checked exceptions for special results (i.e., anticipated situations), and unchecked exceptions to signal bugs (unexpected failures) — makes sense, but it isn’t the end of the story.
The snag is that exceptions in Java aren’t as lightweight as they might be.
      </p>
      <p>
       Aside from the performance penalty, exceptions in Java incur another (more serious) cost: they’re a pain to use, in both method design and method use.
If you
       <em>
        design
       </em>
       a method to have its own (new) exception, you have to create a new class for the exception.
If you
       <em>
        call
       </em>
       a method that can throw a checked exception, you have to wrap it in a
       <code>
        try
       </code>
       -
       <code>
        catch
       </code>
       statement (even if you know the exception will never be thrown).
This latter stipulation creates a dilemma.
Suppose, for example, you’re designing a queue abstraction.
Should popping the queue throw a checked exception when the queue is empty?
Suppose you want to support a style of programming in the client in which the queue is popped (in a loop say) until the exception is thrown.
So you choose a checked exception.
Now some client wants to use the method in a context in which, immediately prior to popping, the client tests whether the queue is empty and only pops if it isn’t.
Maddeningly, that client will still need to wrap the call in a
       <code>
        try
       </code>
       -
       <code>
        catch
       </code>
       statement.
      </p>
      <p>
       This suggests a more refined rule:
      </p>
      <ul>
       <li>
        You should use an unchecked exception only to signal an unexpected failure (i.e. a bug), or if you expect that clients will usually write code that ensures the exception will not happen, because there is a convenient and inexpensive way to avoid the exception;
       </li>
       <li>
        Otherwise you should use a checked exception.
       </li>
      </ul>
      <p>
       Here are some examples of applying this rule to hypothetical methods:
      </p>
      <ul>
       <li>
        <code>
         Queue.pop()
        </code>
        throws an
        <em>
         unchecked
        </em>
        <code>
         Empty­Queue­Exception
        </code>
        when the queue is empty, because it’s reasonable to expect the caller to avoid this with a call like
        <code>
         Queue.size()
        </code>
        or
        <code>
         Queue.isEmpty()
        </code>
        .
       </li>
       <li>
        <code>
         Url.getWebPage()
        </code>
        throws a
        <em>
         checked
        </em>
        <code>
         IOException
        </code>
        when it can’t retrieve the web page, because it’s not easy for the caller to prevent this.
       </li>
       <li>
        <code>
         int integerSquareRoot(int x)
        </code>
        throws a
        <em>
         checked
        </em>
        <code>
         Not­Perfect­Square­Exception
        </code>
        when
        <code>
         x
        </code>
        has no integral square root, because testing whether
        <code>
         x
        </code>
        is a perfect square is just as hard as finding the actual square root, so it’s not reasonable to expect the caller to prevent it.
       </li>
      </ul>
      <p>
       The cost of using exceptions in Java is one reason that many Java API’s use the null reference as a special value.
It’s not a terrible thing to do, so long as it’s done judiciously, and carefully specified.
      </p>
     </div>
     <h2 id="abuse_of_exceptions">
      Abuse of exceptions
     </h2>
     <div data-outline="abuse_of_exceptions">
      <p>
       Here’s an example from
       <a href="http://library.mit.edu/item/001484188">
        <em>
         Effective Java
        </em>
        by Joshua Bloch
       </a>
       (Item 57 in the 2nd edition).
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)
        a[i++].f();
} <span class="hljs-keyword">catch</span> (ArrayIndexOutOfBoundsException e) { }</code></pre>
      <blockquote>
       <p>
        What does this code do? It is not at all obvious from inspection, and that’s reason enough not to use it.
  …
  The infinite loop terminates by throwing, catching, and ignoring an
        <code>
         ArrayIndex­OutOfBounds­Exception
        </code>
        when it attempts to access the first array element outside the bounds of the array.
       </p>
      </blockquote>
      <p>
       It is supposed to be equivalent to:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) {
    a[i].f();
}</code></pre>
      <p>
       Or (using appropriate type
       <code>
        T
       </code>
       ) to:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">for</span> (T x : a) {
    x.f();
}</code></pre>
      <p>
       The exception-based idiom, Bloch writes:
      </p>
      <blockquote>
       <p>
        … is a misguided attempt to improve performance based on the faulty reasoning that, since the VM checks the bounds of array accesses, the normal loop termination test (
        <code>
         i &lt; a.length
        </code>
        ) is redundant and should be avoided.
       </p>
      </blockquote>
      <p>
       However, because exceptions in Java are designed for use only under exceptional circumstances, few, if any, JVM implementations attempt to optimize their performance.
On a typical machine, the exception-based idiom runs 70 times slower than the standard one when looping from 0 to 99.
      </p>
      <p>
       Much worse than that, the exception-based idiom is not even guaranteed to work!
Suppose the computation of
       <code>
        f()
       </code>
       in the body of the loop contains a bug that results in an out-of-bounds access to some unrelated array.
What happens?
      </p>
      <blockquote>
       <p>
        If a reasonable loop idiom were used, the bug would generate an uncaught exception, resulting in immediate thread termination with a full stack trace.
  If the misguided exception-based loop were used, the bug-related exception would be caught and misinterpreted as a normal loop termination.
       </p>
      </blockquote>
     </div>
     <h2 id="next_summary">
      Next:
      <a href="../index.html#summary">
       Summary
      </a>
     </h2>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/06-specifications/exceptions/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:37:16 GMT -->
</html>
<!-- Handout delivered Thu Feb 25 2016 12:33:08 GMT-0500 (EST) -->
