<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/11-debugging/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:51 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 11: Debugging
   </title>
   <link href="../../web/handout-style.css" rel="stylesheet">
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_11_debugging">
      Reading 11: Debugging
     </a>
    </li>
    <li>
     <a href="#reproduce_the_bug">
      Reproduce the Bug
     </a>
    </li>
    <li>
     <a href="#understand_the_location_and_cause_of_the_bug">
      Understand the Location and Cause of the Bug
     </a>
    </li>
    <li>
     <a href="#fix_the_bug">
      Fix the Bug
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_11_debugging">
    Reading 11: Debugging
   </h1>
   <div data-outline="reading_11_debugging">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <h4>
      6.005 Prime Objective
     </h4>
     <table class="table table-striped no-markdown">
      <tbody>
       <tr>
        <th width="33%">
         Safe from bugs
        </th>
        <th>
         Easy to understand
        </th>
        <th>
         Ready for change
        </th>
       </tr>
       <tr>
        <td>
         Correct today and correct in the unknown future.
        </td>
        <td>
         Communicating clearly with future programmers, including future you.
        </td>
        <td>
         Designed to accommodate change without rewriting.
        </td>
       </tr>
      </tbody>
     </table>
     <h4>
      Objectives
     </h4>
     <p>
      The topic of today’s class is systematic debugging.
     </p>
     <p>
      Sometimes you have no choice but to debug – particularly when the bug is found only when you plug the whole system together, or reported by a user after the system is deployed, in which case it may be hard to localize it to a particular module.
For those situations, we can suggest a systematic strategy for more effective debugging.
     </p>
     <h2 id="reproduce_the_bug">
      Reproduce the Bug
     </h2>
     <div data-outline="reproduce_the_bug">
      <p>
       Start by finding a small, repeatable test case that produces the failure.
If the bug was found by regression testing, then you’re in luck; you already have a failing test case in your test suite.
If the bug was reported by a user, it may take some effort to reproduce the bug.
For graphical user interfaces and multithreaded programs, a bug may be hard to reproduce consistently if it depends on timing of events or thread execution.
      </p>
      <p>
       Nevertheless, any effort you put into making the test case small and repeatable will pay off, because you’ll have to run it over and over while you search for the bug and develop a fix for it.
Furthermore, after you’ve successfully fixed the bug, you’ll want to add the test case to your regression test suite, so that the bug never crops up again.
Once you have a test case for the bug, making this test work becomes your goal.
      </p>
      <p>
       Here’s an example. Suppose you have written this function:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/**
 * Find the most common word in a string.
 * <span class="hljs-doctag">@param</span> text string containing zero or more words, where a word
 *     is a string of alphanumeric characters bounded by nonalphanumerics.
 * <span class="hljs-doctag">@return</span> a word that occurs maximally often in text, ignoring alphabetic case.
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">mostCommonWord</span><span class="hljs-params">(String text)</span> </span>{
    ...
}</code></pre>
      <p>
       A user passes the whole text of Shakespeare’s plays into your method, something like
       <code>
        mostCommonWord(allShakespearesPlaysConcatenated)
       </code>
       , and discovers that instead of returning a predictably common English word like
       <code>
        "the"
       </code>
       or
       <code>
        "a"
       </code>
       , the method returns something unexpected, perhaps
       <code>
        "e"
       </code>
       .
      </p>
      <p>
       Shakespeare’s plays have 100,000 lines containing over 800,000 words, so this input would be very painful to debug by normal methods, like print-debugging and breakpoint-debugging.  Debugging will be easier if you first work on reducing the size of the buggy input to something manageable that still exhibits the same (or very similar) bug:
      </p>
      <ul>
       <li>
        does the first half of Shakespeare show the same bug? (Binary search!  Always a good technique. More about this below.)
       </li>
       <li>
        does a single play have the same bug?
       </li>
       <li>
        does a single speech have the same bug?
       </li>
      </ul>
      <p>
       Once you’ve found a small test case, find and fix the bug using that smaller test case, and then go back to the original buggy input and confirm that you fixed the same bug.
      </p>
     </div>
     <h2 id="understand_the_location_and_cause_of_the_bug">
      Understand the Location and Cause of the Bug
     </h2>
     <div data-outline="understand_the_location_and_cause_of_the_bug">
      <p>
       To localize the bug and its cause, you can use the scientific method:
      </p>
      <ol>
       <li>
        <p>
         <strong>
          Study the data.
         </strong>
         Look at the test input that causes the bug, and the incorrect results, failed assertions, and stack traces that result from it.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Hypothesize.
         </strong>
         Propose a hypothesis, consistent with all the data, about where the bug might be, or where it
         <em>
          cannot
         </em>
         be.
It’s good to make this hypothesis general at first.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Experiment.
         </strong>
         Devise an experiment that tests your hypothesis.
It’s good to make the experiment an
         <em>
          observation
         </em>
         at first – a probe that collects information but disturbs the system as little as possible.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Repeat.
         </strong>
         Add the data you collected from your experiment to what you knew before, and make a fresh hypothesis.
Hopefully you have ruled out some possibilities and narrowed the set of possible locations and reasons for the bug.
        </p>
       </li>
      </ol>
      <p>
       Let’s look at these steps in the context of the
       <code>
        mostCommonWord()
       </code>
       example, fleshed out a little more with three helper methods:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/**
 * Find the most common word in a string.
 * <span class="hljs-doctag">@param</span> text string containing zero or more words, 
 *     where a word is a string of alphanumeric 
 *     characters bounded by nonalphanumerics.
 * <span class="hljs-doctag">@return</span> a word that occurs maximally often in text, 
 *         ignoring alphabetic case.
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">mostCommonWord</span><span class="hljs-params">(String text)</span> </span>{
    ... words = splitIntoWords(text); ...
    ... frequencies = countOccurrences(words); ...
    ... winner = findMostCommon(frequencies); ...
    ... <span class="hljs-keyword">return</span> winner;
}

<span class="hljs-comment handout-javadoc-comment">/** Split a string into words ... */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">splitIntoWords</span><span class="hljs-params">(String text)</span> </span>{
    ...
}

<span class="hljs-comment handout-javadoc-comment">/** Count how many times each word appears ... */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,Integer&gt; <span class="hljs-title">countOccurrences</span><span class="hljs-params">(List&lt;String&gt; words)</span> </span>{
    ...
}

<span class="hljs-comment handout-javadoc-comment">/** Find the word with the highest frequency count ... */</span>
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">findMostCommon</span><span class="hljs-params">(Map&lt;String,Integer&gt; frequencies)</span> </span>{
    ...
}</code></pre>
      <h3 id="1_study_the_data">
       1. Study the Data
      </h3>
      <div data-outline="1_study_the_data">
       <p>
        One important form of data is the stack trace from an exception.
Practice reading the stack traces that you get, because they will give you enormous amounts of information about where and what the bug might be.
       </p>
       <p>
        The process of isolating a small test case may also give you data that you didn’t have before.
You may even have two related test cases that
        <em>
         bracket
        </em>
        the bug in the sense that one succeeds and one fails.
For example, maybe
        <code>
         mostCommonWords("c c, b")
        </code>
        is broken, but
        <code>
         mostCommonWords("c c b")
        </code>
        is fine.
       </p>
      </div>
      <h3 id="2_hypothesize">
       2. Hypothesize
      </h3>
      <div data-outline="2_hypothesize">
       <div class="panel panel-figure pull-right pull-margin">
        <img alt="data flowing through the modules of the program" src="figures/dataflow.png" width="400"/>
       </div>
       <p>
        It helps to think about your program as modules, or steps in an algorithm, and try to rule out whole sections of the program at once.
       </p>
       <p>
        The flow of data in
        <code>
         mostCommonWord()
        </code>
        is shown at right.
If the symptom of the bug is an exception in
        <code>
         countOccurrences()
        </code>
        , then you can rule out everything downstream, specifically
        <code>
         findMostFrequent()
        </code>
        .
       </p>
       <p>
        Then you would choose a hypothesis that tries to localize the bug even further.
You might hypothesize that the bug is in
        <code>
         splitIntoWords()
        </code>
        , corrupting its results, which then cause the exception in
        <code>
         countOccurrences()
        </code>
        .
You would then use an experiment to test that hypothesis.
If the hypothesis is true, then you would have ruled out
        <code>
         countOccurrences()
        </code>
        as the source of the problem.
If it’s false, then you would rule out
        <code>
         splitIntoWords()
        </code>
        .
       </p>
      </div>
      <h3 id="3_experiment">
       3. Experiment
      </h3>
      <div data-outline="3_experiment">
       <p>
        A good experiment is a gentle observation of the system without disturbing it much.  It might be:
       </p>
       <ul>
        <li>
         <p>
          Run a
          <strong>
           different test case.
          </strong>
          The test case reduction process discussed above used test cases as experiments.
         </p>
        </li>
        <li>
         <p>
          Insert a
          <strong>
           print statement
          </strong>
          or
          <strong>
           assertion
          </strong>
          in the running program, to check something about its internal state.
         </p>
        </li>
        <li>
         <p>
          Set a
          <strong>
           breakpoint
          </strong>
          using a debugger, then single-step through the code and look at variable and object values.
         </p>
        </li>
       </ul>
       <p>
        It’s tempting to try to insert
        <em>
         fixes
        </em>
        to the hypothesized bug, instead of mere probes.
This is almost always the wrong thing to do.
First, it leads to a kind of ad-hoc guess-and-test programming, which produces awful, complex, hard-to-understand code.
Second, your fixes may just mask the true bug without actually removing it.
       </p>
       <p>
        For example, if you’re getting an
        <code>
         ArrayOutOfBoundsException
        </code>
        , try to understand what’s going on first.
Don’t just add code that avoids or catches the exception, without fixing the real problem.
       </p>
      </div>
      <h3 id="other_tips">
       Other tips
      </h3>
      <div data-outline="other_tips">
       <p>
        <strong>
         Bug localization by binary search
        </strong>
        .
Debugging is a search process, and you can sometimes use binary search to speed up the process.
For example, in
        <code>
         mostCommonWords
        </code>
        , the data flows through three helper methods.
To do a binary search, you would divide this workflow in half, perhaps guessing that the bug is found somewhere between the first helper method call and the second, and insert probes (like breakpoints, print statements, or assertions) there to check the results.
From the answer to that experiment, you would further divide in half.
       </p>
       <p>
        <strong>
         Prioritize your hypotheses
        </strong>
        .
When making your hypothesis, you may want to keep in mind that different parts of the system have different likelihoods of failure.
For example, old, well-tested code is probably more trustworthy than recently-added code.
Java library code is probably more trustworthy than yours.
The Java compiler and runtime, operating system platform, and hardware are increasingly more trustworthy, because they are more tried and tested.
You should trust these lower levels until you’ve found good reason not to.
       </p>
       <p>
        <strong>
         Swap components
        </strong>
        .
If you have another implementation of a module that satisfies the same interface, and you suspect the module, then one experiment you can do is to try swapping in the alternative.
For example, if you suspect your binarySearch() implementation, then substitute a simpler linearSearch() instead.
If you suspect java.util.ArrayList, you could swap in java.util.LinkedList instead.
If you suspect the Java runtime, run with a different version of Java.
If you suspect the operating system, run your program on a different OS.
If you suspect the hardware, run on a different machine.
You can waste a lot of time swapping unfailing components, however, so don’t do this unless you have good reason to suspect a component.
       </p>
       <p>
        <strong>
         Make sure your source code and object code are up to date.
        </strong>
        Pull the latest version from the repository, and delete all your binary files and recompile everything (in Eclipse, this is done by Project → Clean).
       </p>
       <p>
        <strong>
         Get help.
        </strong>
        It often helps to explain your problem to someone else, even if the person you’re talking to has no idea what you’re talking about.
Lab assistants and fellow 6.005 students usually do know what you’re talking about, so they’re even better.
       </p>
       <p>
        <strong>
         Sleep on it.
        </strong>
        If you’re too tired, you won’t be an effective debugger.
Trade latency for efficiency.
       </p>
      </div>
     </div>
     <h2 id="fix_the_bug">
      Fix the Bug
     </h2>
     <div data-outline="fix_the_bug">
      <p>
       Once you’ve found the bug and understand its cause, the third step is to devise a fix for it.
Avoid the temptation to slap a patch on it and move on.
Ask yourself whether the bug was a coding error, like a misspelled variable or interchanged method parameters, or a design error, like an underspecified or insufficient interface.
Design errors may suggest that you step back and revisit your design, or at the very least consider all the other clients of the failing interface to see if they suffer from the bug too.
      </p>
      <p>
       Think also whether the bug has any relatives.
If I just found a divide-by-zero error here, did I do that anywhere else in the code?
Try to make the code safe from future bugs like this.
Also consider what effects your fix will have.
Will it break any other code?
      </p>
      <p>
       Finally, after you have applied your fix, add the bug’s test case to your regression test suite, and run all the tests to assure yourself that (a) the bug is fixed, and (b) no new bugs have been introduced.
      </p>
      <h3 id="summary">
       Summary
      </h3>
      <div data-outline="summary">
       <p>
        In this reading, we looked at how to debug systematically:
       </p>
       <ul>
        <li>
         reproduce the bug as a test case, and put it in your regression suite
        </li>
        <li>
         find the bug using the scientific method
        </li>
        <li>
         fix the bug thoughtfully, not slapdash
        </li>
       </ul>
       <p>
        Thinking about our three main measures of code quality:
       </p>
       <ul>
        <li>
         <strong>
          Safe from bugs.
         </strong>
         We’re trying to prevent them and get rid of them.
        </li>
        <li>
         <strong>
          Easy to understand.
         </strong>
         Techniques like static typing, final declarations, and assertions are additional documentation of the assumptions in your code.  Variable scope minimization makes it easier for a reader to understand how the variable is used, because there’s less code to look at.
        </li>
        <li>
         <strong>
          Ready for change.
         </strong>
         Assertions and static typing document the assumptions in an automatically-checkable way, so that when a future programmer changes the code, accidental violations of those assumptions are detected.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/11-debugging/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:52 GMT -->
</html>
<!-- Handout delivered Wed Feb 17 2016 21:20:10 GMT-0500 (EST) -->
