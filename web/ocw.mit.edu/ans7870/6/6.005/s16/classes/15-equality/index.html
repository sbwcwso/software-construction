<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/15-equality/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:59 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 15: Equality
   </title>
   <link href="../../web/handout-style.css" rel="stylesheet">
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_15_equality">
      Reading 15: Equality
     </a>
    </li>
    <li>
     <a href="#introduction">
      Introduction
     </a>
    </li>
    <li>
     <a href="#three_ways_to_regard_equality">
      Three Ways to Regard Equality
     </a>
    </li>
    <li>
     <a href="#_vs_equals">
      == vs. equals()
     </a>
    </li>
    <li>
     <a href="#equality_of_immutable_types">
      Equality of Immutable Types
     </a>
    </li>
    <li>
     <a href="#the_object_contract">
      The Object Contract
     </a>
    </li>
    <li>
     <a href="#equality_of_mutable_types">
      Equality of Mutable Types
     </a>
    </li>
    <li>
     <a href="#the_final_rule_for_equals_and_hashcode">
      The Final Rule for equals() and hashCode()
     </a>
    </li>
    <li>
     <a href="#summary">
      Summary
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_15_equality">
    Reading 15: Equality
   </h1>
   <div data-outline="reading_15_equality">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <h4>
      Software in 6.005
     </h4>
     <table class="table table-striped no-markdown">
      <tbody>
       <tr>
        <th width="33%">
         Safe from bugs
        </th>
        <th>
         Easy to understand
        </th>
        <th>
         Ready for change
        </th>
       </tr>
       <tr>
        <td>
         Correct today and correct in the unknown future.
        </td>
        <td>
         Communicating clearly with future programmers, including future you.
        </td>
        <td>
         Designed to accommodate change without rewriting.
        </td>
       </tr>
      </tbody>
     </table>
     <h4>
      Objectives
     </h4>
     <ul>
      <li>
       Understand equality defined in terms of the abstraction function, an equivalence relation, and observations.
      </li>
      <li>
       Differentiate between reference equality and object equality.
      </li>
      <li>
       Differentiate between strict observational and behavioral equality for mutable types.
      </li>
      <li>
       Understand the Object contract and be able to implement equality correctly for mutable and immutable types.
      </li>
     </ul>
     <h2 id="introduction">
      Introduction
     </h2>
     <div data-outline="introduction">
      <p>
       In the previous readings we’ve developed a rigorous notion of
       <em>
        data abstraction
       </em>
       by creating types that are characterized by their operations, not by their representation.
For an abstract data type, the
       <em>
        abstraction function
       </em>
       explains how to interpret a concrete representation value as a value of the abstract type, and we saw how the choice of abstraction function determines how to write the code implementing each of the ADT’s operations.
      </p>
      <p>
       In this reading we turn to how we define the notion of
       <em>
        equality
       </em>
       of values in a data type: the abstraction function will give us a way to cleanly define the equality operation on an ADT.
      </p>
      <p>
       In the physical world, every object is distinct – at some level, even two snowflakes are different, even if the distinction is just the position they occupy in space.  (This isn’t strictly true of all subatomic particles, but true enough of large objects like snowflakes and baseballs and people.)  So two physical objects are never truly “equal” to each other; they only have degrees of similarity.
      </p>
      <p>
       In the world of human language, however, and in the world of mathematical concepts, you can have multiple names for the same thing.  So it’s natural to ask when two expressions represent the same thing: 1+2, √9, and 3 are alternative expressions for the same ideal mathematical value.
      </p>
     </div>
     <h2 id="three_ways_to_regard_equality">
      Three Ways to Regard Equality
     </h2>
     <div data-outline="three_ways_to_regard_equality">
      <p>
       Formally, we can regard equality in several ways.
      </p>
      <p>
       <strong>
        Using an abstraction function
       </strong>
       .  Recall that an abstraction function f: R → A maps concrete instances of a data type to their corresponding abstract values.  To use f as a definition for equality, we would say that a equals b if and only if f(a)=f(b).
      </p>
      <p>
       <strong>
        Using a relation
       </strong>
       .  An
       <em>
        equivalence
       </em>
       is a relation E ⊆ T x T that is:
      </p>
      <ul>
       <li>
        reflexive:   E(t,t) ∀ t ∈ T
       </li>
       <li>
        symmetric:  E(t,u) ⇒ E(u,t)
       </li>
       <li>
        transitive: E(t,u) ∧ E(u,v) ⇒ E(t,v)
       </li>
      </ul>
      <p>
       To use E as a definition for equality, we would say that a equals b if and only if E(a,b).
      </p>
      <p>
       These two notions are equivalent.  An equivalence relation induces an abstraction function (the relation partitions T, so f maps each element to its partition class).  The relation induced by an abstraction function is an equivalence relation (check for yourself that the three properties hold).
      </p>
      <p>
       A third way we can talk about the equality between abstract values is in terms of what an outsider (a client) can observe about them:
      </p>
      <p>
       <strong>
        Using observation
       </strong>
       .  We can say that two objects are equal when they cannot be distinguished by observation – every operation we can apply produces the same result for both objects.  Consider the set expressions {1,2} and {2,1}. Using the observer operations available for sets, cardinality |…| and membership ∈, these expressions are indistinguishable:
      </p>
      <ul>
       <li>
        |{1,2}| = 2 and |{2,1}| = 2
       </li>
       <li>
        1 ∈ {1,2} is true, and 1 ∈ {2,1} is true
       </li>
       <li>
        2 ∈ {1,2} is true, and 2 ∈ {2,1} is true
       </li>
       <li>
        3 ∈ {1,2} is false, and 3 ∈ {2,1} is false
       </li>
       <li>
        … and so on
       </li>
      </ul>
      <p>
       In terms of abstract data types, “observation” means calling operations on the objects.  So two objects are equal if and only if they cannot be distinguished by calling any operations of the abstract data type.
      </p>
      <h3 id="example_duration">
       Example: Duration
      </h3>
      <div data-outline="example_duration">
       <p>
        Here’s a simple example of an immutable ADT.
       </p>
       <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duration</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> mins;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> secs;
    <span class="hljs-comment">// rep invariant:</span>
    <span class="hljs-comment">//    mins &gt;= 0, secs &gt;= 0</span>
    <span class="hljs-comment">// abstraction function:</span>
    <span class="hljs-comment">//    represents a span of time of mins minutes and secs seconds</span>

    <span class="hljs-comment handout-javadoc-comment">/** Make a duration lasting for m minutes and s seconds. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Duration</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> s)</span> </span>{
        mins = m; secs = s;
    }
    <span class="hljs-comment handout-javadoc-comment">/** <span class="hljs-doctag">@return</span> length of this duration in seconds */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> mins*<span class="hljs-number">60</span> + secs;
    }
}</code></pre>
       <p>
        Now which of the following values should be considered equal?
       </p>
       <pre><code class="language-java hljs">Duration d1 = <span class="hljs-keyword">new</span> Duration (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
Duration d2 = <span class="hljs-keyword">new</span> Duration (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);
Duration d3 = <span class="hljs-keyword">new</span> Duration (<span class="hljs-number">0</span>, <span class="hljs-number">62</span>);
Duration d4 = <span class="hljs-keyword">new</span> Duration (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</code></pre>
       <p>
        Think in terms of both the abstraction-function definition of equality, and the observational equality definition.
       </p>
      </div>
     </div>
     <h2 id="_vs_equals">
      == vs. equals()
     </h2>
     <div data-outline="_vs_equals">
      <p>
       Like many languages, Java has two different operations for testing equality, with different semantics.
      </p>
      <ul>
       <li>
        The
        <code>
         ==
        </code>
        operator compares references.  More precisely, it tests
        <em>
         referential
        </em>
        equality.  Two references are == if they point to the same storage in memory.  In terms of the snapshot diagrams we’ve been drawing, two references are
        <code>
         ==
        </code>
        if their arrows point to the same object bubble.
       </li>
       <li>
        The
        <code>
         equals()
        </code>
        operation compares object contents – in other words,
        <em>
         object
        </em>
        equality, in the sense that we’ve been talking about in this reading.  The equals operation has to be defined appropriately for every abstract data type.
       </li>
      </ul>
      <p>
       For comparison, here are the equality operators in several languages:
      </p>
      <style>
       <p>.equality-table {
  text-align: center;
}
.equality-table td {
  padding-left: 10px;
  padding-right: 10px;
}</p>
      </style>
      <table class="equality-table">
       <tbody>
        <tr>
         <td>
         </td>
         <td>
          <p>
           <em>
            referential
            <br>
             equality
            </br>
           </em>
          </p>
         </td>
         <td>
          <p>
           <em>
            object
            <br>
             equality
            </br>
           </em>
          </p>
         </td>
        </tr>
        <tr>
         <td>
          <p>
           Java
          </p>
         </td>
         <td>
          <p>
           <code>
            ==
           </code>
          </p>
         </td>
         <td>
          <p>
           <code>
            equals()
           </code>
          </p>
         </td>
        </tr>
        <tr>
         <td>
          <p>
           Objective C
          </p>
         </td>
         <td>
          <p>
           <code>
            ==
           </code>
          </p>
         </td>
         <td>
          <p>
           <code>
            isEqual:
           </code>
          </p>
         </td>
        </tr>
        <tr>
         <td>
          <p>
           C#
          </p>
         </td>
         <td>
          <p>
           <code>
            ==
           </code>
          </p>
         </td>
         <td>
          <p>
           <code>
            Equals()
           </code>
          </p>
         </td>
        </tr>
        <tr>
         <td>
          <p>
           Python
          </p>
         </td>
         <td>
          <p>
           <code>
            is
           </code>
          </p>
         </td>
         <td>
          <p>
           <code>
            ==
           </code>
          </p>
         </td>
        </tr>
        <tr>
         <td>
          <p>
           Javascript
          </p>
         </td>
         <td>
          <p>
           <code>
            ==
           </code>
          </p>
         </td>
         <td>
          <p>
           n/a
          </p>
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       Note that
       <code>
        ==
       </code>
       unfortunately flips its meaning between Java and Python. Don’t let that confuse you:
       <code>
        ==
       </code>
       in Java just tests reference identity, it doesn’t compare object contents.
      </p>
      <p>
       As programmers in any of these languages, we can’t change the meaning of the referential equality operator.  In Java,
       <code>
        ==
       </code>
       always means referential equality. But when we define a new data type, it’s our responsibility to decide what object equality means for values of the data type, and implement the
       <code>
        equals()
       </code>
       operation appropriately.
      </p>
     </div>
     <h2 id="equality_of_immutable_types">
      Equality of Immutable Types
     </h2>
     <div data-outline="equality_of_immutable_types">
      <p>
       The
       <code>
        equals()
       </code>
       method is defined by
       <code>
        Object
       </code>
       , and its default implementation looks like this:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span> </span>{
    ...
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object that)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == that;
    }
}</code></pre>
      <p>
       In other words, the default meaning of
       <code>
        equals()
       </code>
       is the same as referential equality.  For immutable data types, this is almost always wrong.  So you have to
       <strong>
        override
       </strong>
       the
       <code>
        equals()
       </code>
       method, replacing it with your own implementation.
      </p>
      <p>
       Here’s our first try for
       <code>
        Duration
       </code>
       :
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duration</span> </span>{
    ...   
    <span class="hljs-comment">// Problematic definition of equals()</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Duration that)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getLength() == that.getLength();        
    }
}</code></pre>
      <p>
       There’s a subtle problem here.  Why doesn’t this work?  Let’s try this code:
      </p>
      <pre><code class="language-java hljs">Duration d1 = <span class="hljs-keyword">new</span> Duration (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
Duration d2 = <span class="hljs-keyword">new</span> Duration (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
Object o2 = d2;
d1.equals(d2) → <span class="hljs-keyword">true</span>
d1.equals(o2) → <span class="hljs-keyword">false</span></code></pre>
      <p>
       You can
       <a href="http://www.pythontutor.com/java.html#code=public+class+Duration+%7B%0A++++private+final+int+mins%3B%0A++++private+final+int+secs%3B%0A++++//+rep+invariant%3A%0A++++//++++mins+%3E%3D+0,+secs+%3E%3D+0%0A++++//+abstraction+function%3A%0A++++//++++represents+a+span+of+time+of+mins+minutes+and+secs+seconds%0A%0A++++/**+Make+a+duration+lasting+for+m+minutes+and+s+seconds.+*/%0A++++public+Duration(int+m,+int+s%29+%7B%0A++++++++mins+%3D+m%3B+secs+%3D+s%3B%0A++++%7D%0A++++/**+%40return+length+of+this+duration+in+seconds+*/%0A++++public+long+getLength(%29+%7B%0A++++++++return+mins*60+%2B+secs%3B%0A++++%7D%0A++++//+Problematic+definition+of+equals(%29%0A++++public+boolean+equals(Duration+that%29+%7B%0A++++++++return+this.getLength(%29+%3D%3D+that.getLength(%29%3B++++++++%0A++++%7D%0A++++public+static+void+main(String%5B%5D+args%29+%7B%0A++++++Duration+d1+%3D+new+Duration+(1,+2%29%3B%0A++++++Duration+d2+%3D+new+Duration+(1,+2%29%3B%0A++++++Object+o2+%3D+d2%3B%0A++++++System.out.println(%22d1.equals(d2%29%3D%22+%2B+d1.equals(d2%29%29%3B%0A++++++System.out.println(%22d1.equals(o2%29%3D%22+%2B+d1.equals(o2%29%29%3B%0A++++%7D%0A%7D&amp;mode=display&amp;origin=opt-frontend.js&amp;cumulative=false&amp;heapPrimitives=false&amp;textReferences=false&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;curInstr=33">
        see this code in action
       </a>
       .  You’ll see that even though
       <code>
        d2
       </code>
       and
       <code>
        o2
       </code>
       end up referring to the very same object in memory, you still get different results for them from
       <code>
        equals()
       </code>
       .
      </p>
      <p>
       What’s going on?  It turns out that
       <code>
        Duration
       </code>
       has
       <strong>
        overloaded
       </strong>
       the
       <code>
        equals()
       </code>
       method, because the method signature was not identical to
       <code>
        Object
       </code>
       ’s.  We actually have two
       <code>
        equals()
       </code>
       methods in
       <code>
        Duration
       </code>
       : an implicit
       <code>
        equals(Object)
       </code>
       inherited from
       <code>
        Object
       </code>
       , and the new
       <code>
        equals(Duration)
       </code>
       .
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Object</span> </span>{
    <span class="hljs-comment">// explicit method that we declared:</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span> <span class="hljs-params">(Duration that)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getLength() == that.getLength();
    }
    <span class="hljs-comment">// implicit method inherited from Object:</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span> <span class="hljs-params">(Object that)</span> </span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == that;
    }
}</code></pre>
      <p>
       We’ve seen overloading since the very beginning of the course in
       <a href="../01-static-checking/index.html#types">
        static checking
       </a>
       .  Recall from
       <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methods.html">
        the Java Tutorials
       </a>
       that the compiler selects between overloaded operations using the compile-time type of the parameters.  For example, when you use the
       <code>
        /
       </code>
       operator, the compiler chooses either integer division or float division based on whether the arguments are ints or floats.  The same compile-time selection happens here.  If we pass an
       <code>
        Object
       </code>
       reference, as in
       <code>
        d1.equals(o2)
       </code>
       , we end up calling the
       <code>
        equals(Object)
       </code>
       implementation.  If we pass a
       <code>
        Duration
       </code>
       reference, as in
       <code>
        d1.equals(d2)
       </code>
       , we end up calling the
       <code>
        equals(Duration)
       </code>
       version.  This happens even though
       <code>
        o2
       </code>
       and
       <code>
        d2
       </code>
       both point to the same object at runtime!  Equality has become inconsistent.
      </p>
      <p>
       It’s easy to make a mistake in the method signature, and overload a method when you meant to override it.  This is such a common error that Java has a language feature, the annotation
       <a href="https://docs.oracle.com/javase/tutorial/java/annotations/predefined.html">
        <code>
         @Override
        </code>
       </a>
       , which you should use whenever your intention is to override a method in your superclass.  With this annotation, the Java compiler will check that a method with the same signature actually exists in the superclass, and give you a compiler error if you’ve made a mistake in the signature.
      </p>
      <p>
       So here’s the right way to implement
       <code>
        Duration
       </code>
       ’s
       <code>
        equals()
       </code>
       method:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span> <span class="hljs-params">(Object thatObject)</span> </span>{
    <span class="hljs-keyword">if</span> (!(thatObject <span class="hljs-keyword">instanceof</span> Duration)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    Duration thatDuration = (Duration) thatObject;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getLength() == thatDuration.getLength();
}</code></pre>
      <p>
       This fixes the problem:
      </p>
      <pre><code class="language-java hljs">Duration d1 = <span class="hljs-keyword">new</span> Duration(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
Duration d2 = <span class="hljs-keyword">new</span> Duration(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
Object o2 = d2;
d1.equals(d2) → <span class="hljs-keyword">true</span>
d1.equals(o2) → <span class="hljs-keyword">true</span></code></pre>
      <p>
       You can
       <a href="http://www.pythontutor.com/java.html#code=public+class+Duration+%7B%0A++++private+final+int+mins%3B%0A++++private+final+int+secs%3B%0A++++//+rep+invariant%3A%0A++++//++++mins+%3E%3D+0,+secs+%3E%3D+0%0A++++//+abstraction+function%3A%0A++++//++++represents+a+span+of+time+of+mins+minutes+and+secs+seconds%0A%0A++++/**+Make+a+duration+lasting+for+m+minutes+and+s+seconds.+*/%0A++++public+Duration(int+m,+int+s%29+%7B%0A++++++++mins+%3D+m%3B+secs+%3D+s%3B%0A++++%7D%0A++++/**+%40return+length+of+this+duration+in+seconds+*/%0A++++public+long+getLength(%29+%7B%0A++++++++return+mins*60+%2B+secs%3B%0A++++%7D%0A++++%40Override%0A++++public+boolean+equals+(Object+thatObject%29+%7B%0A++++++++if+(!(thatObject+instanceof+Duration%29%29+return+false%3B%0A++++++++Duration+thatDuration+%3D+(Duration%29+thatObject%3B%0A++++++++return+this.getLength(%29+%3D%3D+thatDuration.getLength(%29%3B%0A++++%7D%0A++++public+static+void+main(String%5B%5D+args%29+%7B%0A++++++Duration+d1+%3D+new+Duration+(1,+2%29%3B%0A++++++Duration+d2+%3D+new+Duration+(1,+2%29%3B%0A++++++Object+o2+%3D+d2%3B%0A++++++System.out.println(%22d1.equals(d2%29%3D%22+%2B+d1.equals(d2%29%29%3B%0A++++++System.out.println(%22d1.equals(o2%29%3D%22+%2B+d1.equals(o2%29%29%3B%0A++++%7D%0A%7D&amp;mode=display&amp;origin=opt-frontend.js&amp;cumulative=false&amp;heapPrimitives=false&amp;textReferences=false&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;curInstr=49">
        see this code in action
       </a>
       in the Online Python Tutor.
      </p>
      <h3 id="instanceof">
       instanceof
      </h3>
      <div data-outline="instanceof">
       <p>
        The
        <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/op2.html">
         <code>
          instanceof
         </code>
         operator
        </a>
        tests whether an object is an instance of a particular type.
Using
        <code>
         instanceof
        </code>
        is dynamic type checking, not the static type checking we vastly prefer.
In general, using
        <code>
         instanceof
        </code>
        in object-oriented programming is a bad smell.
In 6.005 — and this is another of our rules that holds true in most good Java programming —
        <strong>
         <code>
          instanceof
         </code>
         is disallowed anywhere except for implementing
         <code>
          equals
         </code>
        </strong>
        .
This prohibition also includes other ways of inspecting objects’ runtime types.
For example,
        <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#getClass--">
         <code>
          getClass
         </code>
        </a>
        is also disallowed.
       </p>
       <p>
        We’ll see examples of when you might be tempted to use
        <code>
         instanceof
        </code>
        , and how to write alternatives that are safer from bugs and more ready for change, in a future reading.
       </p>
      </div>
     </div>
     <h2 id="the_object_contract">
      The Object Contract
     </h2>
     <div data-outline="the_object_contract">
      <p>
       The specification of the
       <code>
        Object
       </code>
       class is so important that it is often referred to as
       <em>
        the
        <code>
         Object
        </code>
        Contract
       </em>
       .  The contract can be found in the method specifications for the
       <code>
        Object
       </code>
       class. Here we will focus on the contract for
       <code>
        equals
       </code>
       . When you override the
       <code>
        equals
       </code>
       method, you must adhere to its general contract. It states that:
      </p>
      <ul>
       <li>
        <code>
         equals
        </code>
        must define an equivalence relation – that is, a relation that is reflexive, symmetric, and transitive;
       </li>
       <li>
        <code>
         equals
        </code>
        must be consistent: repeated calls to the method must yield the same result provided no information used in
        <code>
         equals
        </code>
        comparisons on the object is modified;
       </li>
       <li>
        for a non-null reference
        <code>
         x
        </code>
        ,
        <code>
         x.equals(null)
        </code>
        should return false;
       </li>
       <li>
        <code>
         hashCode
        </code>
        must produce the same result for two objects that are deemed equal by the
        <code>
         equals
        </code>
        method.
       </li>
      </ul>
      <h3 id="breaking_the_equivalence_relation">
       Breaking the Equivalence Relation
      </h3>
      <div data-outline="breaking_the_equivalence_relation">
       <p>
        Let’s start with the equivalence relation.  We have to make sure that the definition of equality implemented by
        <code>
         equals()
        </code>
        is actually an equivalence relation as defined earlier: reflexive, symmetric, and transitive.  If it isn’t, then operations that depend on equality (like sets, searching) will behave erratically and unpredictably.  You don’t want to program with a data type in which sometimes
        <code>
         a
        </code>
        equals
        <code>
         b
        </code>
        , but
        <code>
         b
        </code>
        doesn’t equal
        <code>
         a
        </code>
        .  Subtle and painful bugs will result.
       </p>
       <p>
        Here’s an example of how an innocent attempt to make equality more flexible can go wrong.  Suppose we wanted to allow for a tolerance in comparing
        <code>
         Duration
        </code>
        objects, because different computers may have slightly unsynchronized clocks:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CLOCK_SKEW = <span class="hljs-number">5</span>; <span class="hljs-comment">// seconds</span>

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span> <span class="hljs-params">(Object thatObject)</span> </span>{
    <span class="hljs-keyword">if</span> (!(thatObject <span class="hljs-keyword">instanceof</span> Duration)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
    Duration thatDuration = (Duration) thatObject;
    <span class="hljs-keyword">return</span> Math.abs(<span class="hljs-keyword">this</span>.getLength() - thatDuration.getLength()) &lt;= CLOCK_SKEW;
}</code></pre>
       <p>
        Which property of the equivalence relation is violated?
       </p>
      </div>
      <h3 id="breaking_hash_tables">
       Breaking Hash Tables
      </h3>
      <div data-outline="breaking_hash_tables">
       <p>
        To understand the part of the contract relating to the
        <code>
         hashCode
        </code>
        method, you’ll need to have some idea of how hash tables work.  Two very common collection implementations,
        <code>
         HashSet
        </code>
        and
        <code>
         HashMap
        </code>
        , use a hash table data structure, and depend on the
        <code>
         hashCode
        </code>
        method to be implemented correctly for the objects stored in the set and used as keys in the map.
       </p>
       <p>
        A hash table is a representation for a mapping: an abstract data type that maps keys to values. Hash tables offer constant time lookup, so they tend to perform better than trees or lists. Keys don’t have to be ordered, or have any particular property, except for offering
        <code>
         equals
        </code>
        and
        <code>
         hashCode
        </code>
        .
       </p>
       <p>
        Here’s how a hash table works. It contains an array that is initialized to a size corresponding to the number of elements that we expect to be inserted. When a key and a value are presented for insertion, we compute the hashcode of the key, and convert it into an index in the array’s range (e.g., by a modulo division). The value is then inserted at that index.
       </p>
       <p>
        The rep invariant of a hash table includes the fundamental constraint that keys are in the slots determined by their hash codes.
       </p>
       <p>
        Hashcodes are designed so that the keys will be spread evenly over the indices. But occasionally a conflict occurs, and two keys are placed at the same index. So rather than holding a single value at an index, a hash table actually holds a list of key/value pairs, usually called a
        <em>
         hash bucket
        </em>
        .  A key/value pair is implemented in Java simply as an object with two fields. On insertion, you add a pair to the list in the array slot determined by the hash code. For lookup, you hash the key, find the right slot, and then examine each of the pairs until one is found whose key equals the query key.
       </p>
       <p>
        Now it should be clear why the
        <code>
         Object
        </code>
        contract requires equal objects to have the same hashcode. If two equal objects had distinct hashcodes, they might be placed in different slots. So if you attempt to lookup a value using a key equal to the one with which it was inserted, the lookup may fail.
       </p>
       <p>
        <code>
         Object
        </code>
        ’s default
        <code>
         hashCode()
        </code>
        implementation is consistent with its default
        <code>
         equals()
        </code>
        :
       </p>
       <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Object</span> </span>{
  ...
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object that)</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span> == that; }
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> <span class="hljs-comment">/* the memory address of this */</span>; }
}</code></pre>
       <p>
        For references
        <code>
         a
        </code>
        and
        <code>
         b
        </code>
        , if
        <code>
         a == b
        </code>
        , then the address of a
        <code>
         ==
        </code>
        the address of b.  So the
        <code>
         Object
        </code>
        contract is satisfied.
       </p>
       <p>
        But immutable objects need a different implementation of
        <code>
         hashCode()
        </code>
        .  For
        <code>
         Duration
        </code>
        , since we haven’t overridden the default
        <code>
         hashCode()
        </code>
        yet, we’re currently breaking the
        <code>
         Object
        </code>
        contract:
       </p>
       <pre><code class="language-java hljs">Duration d1 = <span class="hljs-keyword">new</span> Duration(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
Duration d2 = <span class="hljs-keyword">new</span> Duration(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
d1.equals(d2) → <span class="hljs-keyword">true</span>
d1.hashCode() → <span class="hljs-number">2392</span>
d2.hashCode() → <span class="hljs-number">4823</span></code></pre>
       <p>
        <code>
         d1
        </code>
        and
        <code>
         d2
        </code>
        are
        <code>
         equal()
        </code>
        , but they have different hash codes.  So we need to fix that.
       </p>
       <p>
        A simple and drastic way to ensure that the contract is met is for
        <code>
         hashCode
        </code>
        to always return some constant value, so every object’s hash code is the same. This satisfies the
        <code>
         Object
        </code>
        contract, but it would have a disastrous performance effect, since every key will be stored in the same slot, and every lookup will degenerate to a linear search along a long list.
       </p>
       <p>
        The standard way to construct a more reasonable hash code that still satisfies the contract is to compute a hash code for each component of the object that is used in the determination of equality (usually by calling the
        <code>
         hashCode
        </code>
        method of each component), and then combining these, throwing in a few arithmetic operations. For
        <code>
         Duration
        </code>
        , this is easy, because the abstract value of the class is already an integer value:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) getLength();
}</code></pre>
       <p>
        Josh Bloch’s fantastic book,
        <em>
         Effective Java
        </em>
        , explains this issue in more detail, and gives some strategies for writing decent hash code functions.  The advice is summarized in
        <a href="http://stackoverflow.com/questions/113511/hash-code-implementation">
         a good StackOverflow post
        </a>
        .  Recent versions of Java now have a utility method
        <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Objects.html#hash-java.lang.Object...-">
         <code>
          Objects.hash()
         </code>
        </a>
        that makes it easier to implement a hash code involving multiple fields.
       </p>
       <p>
        Note, however, that as long as you satisfy the requirement that equal objects have the same hash code value, then the particular hashing technique you use doesn’t make a difference to the correctness of your code.  It may affect its performance, by creating unnecessary collisions between different objects, but even a poorly-performing hash function is better than one that breaks the contract.
       </p>
       <p>
        Most crucially, note that if you don’t override
        <code>
         hashCode
        </code>
        at all, you’ll get the one from
        <code>
         Object
        </code>
        , which is based on the address of the object. If you have overridden
        <code>
         equals
        </code>
        , this will mean that you will have almost certainly violated the contract. So as a general rule:
       </p>
       <blockquote>
        <p>
         <strong>
          Always override
          <code>
           hashCode
          </code>
          when you override
          <code>
           equals
          </code>
          .
         </strong>
        </p>
       </blockquote>
       <p>
        Many years ago in (a precursor to 6.005 confusingly numbered) 6.170, a student spent hours tracking down a bug in a project that amounted to nothing more than misspelling
        <code>
         hashCode
        </code>
        as
        <code>
         hashcode
        </code>
        . This created a new method that didn’t override the
        <code>
         hashCode
        </code>
        method of
        <code>
         Object
        </code>
        at all, and strange things happened. Use
        <code>
         @Override
        </code>
        !
       </p>
      </div>
     </div>
     <h2 id="equality_of_mutable_types">
      Equality of Mutable Types
     </h2>
     <div data-outline="equality_of_mutable_types">
      <p>
       We’ve been focusing on equality of immutable objects so far in this reading.  What about mutable objects?
      </p>
      <p>
       Recall our definition: two objects are equal when they cannot be distinguished by observation.  With mutable objects, there are two ways to interpret this:
      </p>
      <ul>
       <li>
        when they cannot be distinguished by observation
        <em>
         that doesn’t change the state of the objects
        </em>
        , i.e., by calling only observer, producer, and creator methods.  This is often strictly called
        <strong>
         observational equality
        </strong>
        , since it tests whether the two objects “look” the same, in the current state of the program.
       </li>
       <li>
        when they cannot be distinguished by
        <em>
         any
        </em>
        observation, even state changes.  This interpretation allows calling any methods on the two objects, including mutators.  This is often called
        <strong>
         behavioral equality
        </strong>
        , since it tests whether the two objects will “behave” the same, in this and all future states.
       </li>
      </ul>
      <p>
       For immutable objects, observational and behavioral equality are identical, because there aren’t any mutator methods.
      </p>
      <p>
       For mutable objects, it’s tempting to implement strict observational equality.  Java uses observational equality for most of its mutable data types, in fact.  If two distinct
       <code>
        List
       </code>
       objects contain the same sequence of elements, then
       <code>
        equals()
       </code>
       reports that they are equal.
      </p>
      <p>
       But using observational equality leads to subtle bugs, and in fact allows us to easily break the rep invariants of other collection data structures.  Suppose we make a
       <code>
        List
       </code>
       , and then drop it into a
       <code>
        Set
       </code>
       :
      </p>
      <pre><code class="language-java hljs">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();
list.add(<span class="hljs-string">"a"</span>);

Set&lt;List&lt;String&gt;&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;List&lt;String&gt;&gt;();
set.add(list);</code></pre>
      <p>
       We can check that the set contains the list we put in it, and it does:
      </p>
      <pre><code class="language-java hljs">set.contains(list) → <span class="hljs-keyword">true</span></code></pre>
      <p>
       But now we mutate the list:
      </p>
      <pre><code class="language-java hljs">list.add(<span class="hljs-string">"goodbye"</span>);</code></pre>
      <p>
       And it no longer appears in the set!
      </p>
      <pre><code class="language-java hljs">set.contains(list) → <span class="hljs-keyword">false</span>!</code></pre>
      <p>
       It’s worse than that, in fact:  when we iterate over the members of the set, we still find the list in there, but
       <code>
        contains()
       </code>
       says it’s not there!
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">for</span> (List&lt;String&gt; l : set) { 
    set.contains(l) → <span class="hljs-keyword">false</span>! 
}</code></pre>
      <p>
       If the set’s own iterator and its own
       <code>
        contains()
       </code>
       method disagree about whether an element is in the set, then the set clearly is broken.  You can
       <a href="http://www.pythontutor.com/java.html#code=import+java.util.*%3B%0Apublic+class+WhyObservationalEqualityHurts+%7B%0A++public+static+void+main(String%5B%5D+args%29+%7B%0A++++List%3CString%3E+list+%3D+new+ArrayList%3C%3E(%29%3B%0A++++list.add(%22a%22%29%3B%0A++++Set%3CList%3CString%3E%3E+set+%3D+new+HashSet%3CList%3CString%3E%3E(%29%3B%0A++++set.add(list%29%3B%0A++++System.out.println(%22set.contains(list%29%3D%22+%2B+set.contains(list%29%29%3B%0A++++list.add(%22goodbye%22%29%3B%0A++++System.out.println(%22set.contains(list%29%3D%22+%2B+set.contains(list%29%29%3B%0A++++for+(List%3CString%3E+l+%3A+set%29+%7B+%0A++++++System.out.println(%22set.contains(l%29%3D%22+%2B+set.contains(l%29%29%3B%0A++++%7D%0A++%7D%0A%7D&amp;mode=display&amp;origin=opt-frontend.js&amp;cumulative=false&amp;heapPrimitives=false&amp;textReferences=false&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;curInstr=13">
        see this code in action
       </a>
       on Online Python Tutor.
      </p>
      <p>
       What’s going on?
       <code>
        List&lt;String&gt;
       </code>
       is a mutable object.  In the standard Java implementation of collection classes like
       <code>
        List
       </code>
       , mutations affect the result of
       <code>
        equals()
       </code>
       and
       <code>
        hashCode()
       </code>
       .  When the list is first put into the
       <code>
        HashSet
       </code>
       , it is stored in the hash bucket corresponding to its
       <code>
        hashCode()
       </code>
       result at that time.  When the list is subsequently mutated, its
       <code>
        hashCode()
       </code>
       changes, but
       <code>
        HashSet
       </code>
       doesn’t realize it should be moved to a different bucket.  So it can never be found again.
      </p>
      <p>
       When
       <code>
        equals()
       </code>
       and
       <code>
        hashCode()
       </code>
       can be affected by mutation, we can break the rep invariant of a hash table that uses that object as a key.
      </p>
      <p>
       Here’s a telling quote from the specification of
       <code>
        java.util.Set
       </code>
       :
      </p>
      <blockquote>
       <p>
        Note: Great care must be exercised if mutable objects are used as set elements. The behavior of a set is not specified if the value of an object is changed in a manner that affects equals comparisons while the object is an element in the set.
       </p>
      </blockquote>
      <p>
       The Java library is unfortunately inconsistent about its interpretation of
       <code>
        equals()
       </code>
       for mutable classes.  Collections use observational equality, but other mutable classes (like
       <code>
        StringBuilder
       </code>
       ) use behavioral equality.
      </p>
      <p>
       The lesson we should draw from this example is that
       <strong>
        <code>
         equals()
        </code>
        should implement behavioral equality
       </strong>
       .  In general, that means that two references should be
       <code>
        equals()
       </code>
       if and only if they are aliases for the same object.  So mutable objects should just inherit
       <code>
        equals()
       </code>
       and
       <code>
        hashCode()
       </code>
       from
       <code>
        Object
       </code>
       .  For clients that need a notion of observational equality (whether two mutable objects “look” the same in the current state), it’s better to define a new method, e.g.,
       <code>
        similar()
       </code>
       .
      </p>
     </div>
     <h2 id="the_final_rule_for_equals_and_hashcode">
      The Final Rule for equals() and hashCode()
     </h2>
     <div data-outline="the_final_rule_for_equals_and_hashcode">
      <p>
       <strong>
        For immutable types
       </strong>
       :
      </p>
      <ul>
       <li>
        <code>
         equals()
        </code>
        should compare abstract values.  This is the same as saying
        <code>
         equals()
        </code>
        should provide behavioral equality.
       </li>
       <li>
        <code>
         hashCode()
        </code>
        should map the abstract value to an integer.
       </li>
      </ul>
      <p>
       So immutable types must override both
       <code>
        equals()
       </code>
       and
       <code>
        hashCode()
       </code>
       .
      </p>
      <p>
       <strong>
        For mutable types
       </strong>
       :
      </p>
      <ul>
       <li>
        <code>
         equals()
        </code>
        should compare references, just like
        <code>
         ==
        </code>
        .   Again, this is the same as saying
        <code>
         equals()
        </code>
        should provide behavioral equality.
       </li>
       <li>
        <code>
         hashCode()
        </code>
        should map the reference into an integer.
       </li>
      </ul>
      <p>
       So mutable types should not override
       <code>
        equals()
       </code>
       and
       <code>
        hashCode()
       </code>
       at all, and should simply use the default implementations provided by
       <code>
        Object
       </code>
       .  Java doesn’t follow this rule for its collections, unfortunately, leading to the pitfalls that we saw above.
      </p>
      <h3 id="autoboxing_and_equality">
       Autoboxing and Equality
      </h3>
      <div data-outline="autoboxing_and_equality">
       <p>
        One more instructive pitfall in Java.  We’ve talked about primitive types and their object type equivalents – for example,
        <code>
         int
        </code>
        and
        <code>
         Integer
        </code>
        .  The object type implements
        <code>
         equals()
        </code>
        in the correct way, so that if you create two
        <code>
         Integer
        </code>
        objects with the same value, they’ll be
        <code>
         equals()
        </code>
        to each other:
       </p>
       <pre><code class="language-java hljs">Integer x = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>);
Integer y = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">3</span>);
x.equals(y) → <span class="hljs-keyword">true</span></code></pre>
       <p>
        But there’s a subtle problem here;
        <code>
         ==
        </code>
        is overloaded.  For reference types like
        <code>
         Integer
        </code>
        , it implements referential equality:
       </p>
       <pre><code class="language-java hljs">x == y <span class="hljs-comment">// returns false</span></code></pre>
       <p>
        But for primitive types like
        <code>
         int
        </code>
        ,
        <code>
         ==
        </code>
        implements behavioral equality:
       </p>
       <pre><code class="language-java hljs">(<span class="hljs-keyword">int</span>)x == (<span class="hljs-keyword">int</span>)y <span class="hljs-comment">// returns true</span></code></pre>
       <p>
        So you can’t really use
        <code>
         Integer
        </code>
        interchangeably with
        <code>
         int
        </code>
        .  The fact that Java automatically converts between
        <code>
         int
        </code>
        and
        <code>
         Integer
        </code>
        (this is called
        <em>
         autoboxing
        </em>
        and
        <em>
         autounboxing
        </em>
        ) can lead to subtle bugs!  You have to be aware what the compile-time types of your expressions are.  Consider this:
       </p>
       <pre><code class="language-java hljs">Map&lt;String, Integer&gt; a = <span class="hljs-keyword">new</span> HashMap(), b = <span class="hljs-keyword">new</span> HashMap();
a.put(<span class="hljs-string">"c"</span>, <span class="hljs-number">130</span>); <span class="hljs-comment">// put ints into the map</span>
b.put(<span class="hljs-string">"c"</span>, <span class="hljs-number">130</span>);
a.get(<span class="hljs-string">"c"</span>) == b.get(<span class="hljs-string">"c"</span>) → ?? <span class="hljs-comment">// what do we get out of the map?</span></code></pre>
       <p>
        You can
        <a href="http://www.pythontutor.com/java.html#code=import+java.util.*%3B%0Apublic+class+AutounboxingProblem+%7B%0A++public+static+void+main(String%5B%5D+args%29+%7B%0A++++Map%3CString,+Integer%3E+a+%3D+new+HashMap(%29,+b+%3D+new+HashMap(%29%3B%0A++++a.put(%22c%22,+130%29%3B+//+put+ints+into+the+map%0A++++b.put(%22c%22,+130%29%3B%0A++++System.out.println(%22a.get(%5C%22c%5C%22%29+%3D%3D+b.get(%5C%22c%5C%22%29+returns+%22%0A++++++++++++++++++++++++%2B+(a.get(%22c%22%29+%3D%3D+b.get(%22c%22%29%29+%29%3B%0A++%7D%0A%7D&amp;mode=display&amp;origin=opt-frontend.js&amp;cumulative=false&amp;heapPrimitives=false&amp;textReferences=false&amp;py=java&amp;rawInputLstJSON=%5B%5D&amp;curInstr=6">
         see this code in action
        </a>
        on Online Python Tutor.
       </p>
      </div>
     </div>
     <h2 id="summary">
      Summary
     </h2>
     <div data-outline="summary">
      <ul>
       <li>
        Equality should be an equivalence relation (reflexive, symmetric, transitive).
       </li>
       <li>
        Equality and hash code must be consistent with each other, so that data structures that use hash tables (like
        <code>
         HashSet
        </code>
        and
        <code>
         HashMap
        </code>
        ) work properly.
       </li>
       <li>
        The abstraction function is the basis for equality in immutable data types.
       </li>
       <li>
        Reference equality is the basis for equality in mutable data types; this is the only way to ensure consistency over time and avoid breaking rep invariants of hash tables.
       </li>
      </ul>
      <p>
       Equality is one part of implementing an abstract data type, and we’ve already seen how important ADTs are to achieving our three primary objectives.
Let’s look at equality in particular:
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Safe from bugs
         </strong>
         .
Correct implementation of equality and hash codes is necessary for use with collection data types like sets and maps.
It’s also highly desirable for writing tests.
Since every object in Java inherits the
         <code>
          Object
         </code>
         implementations, immutable types must override them.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Easy to understand
         </strong>
         .
Clients and other programmers who read our specs will expect our types to implement an appropriate equality operation, and will be surprised and confused if we do not.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Ready for change
         </strong>
         .
Correctly-implemented equality for
         <em>
          immutable
         </em>
         types separates equality of reference from equality of abstract value, hiding from clients our decisions about whether values are shared.
Choosing behavioral rather than observational equality for
         <em>
          mutable
         </em>
         types helps avoid unexpected aliasing bugs.
        </p>
       </li>
      </ul>
     </div>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/15-equality/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:59 GMT -->
</html>
<!-- Handout delivered Mon Mar 07 2016 10:17:11 GMT-0500 (EST) -->
