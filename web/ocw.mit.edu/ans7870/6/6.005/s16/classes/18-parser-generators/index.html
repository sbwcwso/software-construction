<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/18-parser-generators/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:36:05 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 18: Parser Generators
   </title>
   <link href="../../web/handout-style.css" rel="stylesheet">
    <style>
     /* links to example code */
.pull-margin .handout-solo {
  position: absolute; top: 4px; right: 4px; padding: 8px;
}
    </style>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_18_parser_generators">
      Reading 18: Parser Generators
     </a>
    </li>
    <li>
     <a href="#parser_generators">
      Parser Generators
     </a>
    </li>
    <li>
     <a href="#an_antlr_grammar">
      An Antlr Grammar
     </a>
    </li>
    <li>
     <a href="#generating_the_parser">
      Generating the parser
     </a>
    </li>
    <li>
     <a href="#calling_the_parser">
      Calling the parser
     </a>
    </li>
    <li>
     <a href="#traversing_the_parse_tree">
      Traversing the parse tree
     </a>
    </li>
    <li>
     <a href="#constructing_an_abstract_syntax_tree">
      Constructing an abstract syntax tree
     </a>
    </li>
    <li>
     <a href="#handling_errors">
      Handling errors
     </a>
    </li>
    <li>
     <a href="#summary">
      Summary
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_18_parser_generators">
    Reading 18: Parser Generators
   </h1>
   <div data-outline="reading_18_parser_generators">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <h4>
      Software in 6.005
     </h4>
     <table class="table table-striped no-markdown">
      <tbody>
       <tr>
        <th width="33%">
         Safe from bugs
        </th>
        <th>
         Easy to understand
        </th>
        <th>
         Ready for change
        </th>
       </tr>
       <tr>
        <td>
         Correct today and correct in the unknown future.
        </td>
        <td>
         Communicating clearly with future programmers, including future you.
        </td>
        <td>
         Designed to accommodate change without rewriting.
        </td>
       </tr>
      </tbody>
     </table>
     <h4>
      Objectives
     </h4>
     <p>
      After today’s class, you should:
     </p>
     <ul>
      <li>
       Be able to use a grammar in combination with a parser generator, to parse a character sequence into a parse tree
      </li>
      <li>
       Be able to convert a parse tree into a useful data type
      </li>
     </ul>
     <h2 id="parser_generators">
      Parser Generators
     </h2>
     <div data-outline="parser_generators">
      <p>
       A
       <em>
        parser generator
       </em>
       is a good tool that you should make part of your toolbox.  A parser generator takes a grammar as input and automatically generates source code that can parse streams of characters using the grammar.
      </p>
      <p>
       The generated code is a
       <em>
        parser
       </em>
       , which takes a sequence of characters and tries to match the sequence against the grammar.  The parser typically produces a
       <em>
        parse tree
       </em>
       , which shows how  grammar productions are expanded into a sentence that matches the character sequence.  The root of the parse tree is the starting nonterminal of the grammar.  Each node of the parse tree expands into one production of the grammar.  We’ll see how a parse tree actually looks in the next section.
      </p>
      <p>
       The final step of parsing is to do something useful with this parse tree.  We’re going to translate it into a value of a recursive data type.  Recursive abstract data types are often used to represent an expression in a language, like HTML, or Markdown, or Java, or algebraic expressions.  A recursive abstract data type that represents a language expression is called an
       <em>
        abstract syntax tree
       </em>
       (AST).
      </p>
      <p>
       Antlr is a mature and widely-used parser generator for Java, and other languages as well.  The remainder of this reading will get you started with Antlr.  If you run into trouble and need a deeper reference, you can look at:
      </p>
      <ul>
       <li>
        <a href="https://www.google.com/search?q=The+Definitive+Antlr+4+Reference">
         Definitive Antlr 4 Reference
        </a>
        . A book about Antlr, both tutorial and reference.
       </li>
       <li>
        <a href="https://theantlrguy.atlassian.net/wiki/display/ANTLR4/ANTLR+4+Documentation">
         Antlr 4 Documentation Wiki
        </a>
        .  Concise documentation of the grammar file syntax.
       </li>
       <li>
        <a href="http://www.antlr.org/api/Java/">
         Antlr 4 Runtime API
        </a>
        .  Reference documentation for Antlr’s Java classes and interfaces.
       </li>
      </ul>
     </div>
     <h2 id="an_antlr_grammar">
      An Antlr Grammar
     </h2>
     <div data-outline="an_antlr_grammar">
      <div class="handout-solo alert alert-warning">
       <p>
        The code for the examples that follow can be found on GitHub as
        <a class="alert-link" href="https://github.com/mit6005/sp16-ex18-parser-generators">
         sp16-ex18-parser-generators
        </a>
        .
       </p>
      </div>
      <p>
       Here is what our HTML grammar looks like as an Antlr source file:
      </p>
      <div class="pull-margin">
       <pre><code class="language-python hljs">grammar Html;

root : html EOF;
html : ( italic | normal ) *;
italic : <span class="hljs-string">'&lt;i&gt;'</span> html <span class="hljs-string">'&lt;/i&gt;'</span>;
normal : TEXT; 
TEXT : ~[&lt;&gt;]+;  /* represents a string of one <span class="hljs-keyword">or</span> more characters that are <span class="hljs-keyword">not</span> &lt; <span class="hljs-keyword">or</span> &gt; </code></pre>
      </div>
      <p>
       Let’s break it down.
      </p>
      <p>
       Each Antlr rule consists of a name, followed by a colon, followed by its definition, terminated by a semicolon.
      </p>
      <p>
       Nonterminals in Antlr have to be lowercase:
       <code>
        root
       </code>
       ,
       <code>
        html
       </code>
       ,
       <code>
        normal
       </code>
       ,
       <code>
        italic
       </code>
       .  Terminals are either quoted strings, like
       <code>
        '&lt;i&gt;'
       </code>
       , or capitalized names, like
       <code>
        EOF
       </code>
       and
       <code>
        TEXT
       </code>
       .
      </p>
      <pre><code class="language-python hljs">root : html EOF;</code></pre>
      <p>
       <code>
        root
       </code>
       is the entry point of the grammar.  This is the nonterminal that the whole input needs to match.  We don’t have to call it
       <code>
        root
       </code>
       .  The entry point can be any nonterminal.
      </p>
      <p>
       <code>
        EOF
       </code>
       is a special terminal, defined by Antlr, that means the end of the input.  It stands for
       <em>
        end of file
       </em>
       , though your input may also come from a string or a network connection rather than just a file.
      </p>
      <pre><code class="language-python hljs">html : ( normal | italic ) *;</code></pre>
      <p>
       This rule shows that Antlr rules can have the alternation operator
       <code>
        |
       </code>
       ,  the repetition operators
       <code>
        *
       </code>
       and
       <code>
        +
       </code>
       , and parentheses for grouping, in the same way we’ve been using in the
       <a href="../17-regex-grammars/index.html#grammars">
        grammars reading
       </a>
       .  Optional parts can be marked with
       <code>
        ?
       </code>
       , just like we did earlier, but this particular grammar doesn’t use
       <code>
        ?
       </code>
       .
      </p>
      <pre><code class="language-python hljs">italic : <span class="hljs-string">'&lt;i&gt;'</span> html <span class="hljs-string">'&lt;/i&gt;'</span>;
normal : TEXT; 
TEXT : ~[&lt;&gt;]+;</code></pre>
      <p>
       <code>
        TEXT
       </code>
       is a terminal matching sequences of characters that are neither
       <code>
        &lt;
       </code>
       nor
       <code>
        &gt;
       </code>
       .  In the more conventional regular expression syntax used earlier in this reading, we would write
       <code>
        [^&lt;&gt;]
       </code>
       to represent all characters except
       <code>
        &lt;
       </code>
       and
       <code>
        &gt;
       </code>
       .  Antlr uses a slightly different syntax –
       <code>
        ~
       </code>
       means
       <em>
        not
       </em>
       , and it is put in front of the square brackets instead of inside them, so
       <code>
        ~[&lt;&gt;]
       </code>
       matches any character except
       <code>
        &lt;
       </code>
       and
       <code>
        &gt;
       </code>
       .
      </p>
      <p>
       In Antlr, terminals can be defined using regular expressions, not just fixed strings.  For example, here are some other terminal patterns we used in the URL grammar earlier in the reading, now written in Antlr syntax and with Antlr’s required naming convention:
      </p>
      <pre><code class="language-python hljs">IDENTIFIER : [a-z]+;
INTEGER : [<span class="hljs-number">0</span><span class="hljs-number">-9</span>]+;</code></pre>
      <p>
       More about Antlr’s grammar file syntax can be found in Chapter 5 of the
       <a href="https://www.google.com/search?q=The+Definitive+Antlr+4+Reference">
        Definitive ANTLR 4 Reference
       </a>
       .
      </p>
     </div>
     <h2 id="generating_the_parser">
      Generating the parser
     </h2>
     <div data-outline="generating_the_parser">
      <p>
       The rest of this reading will focus on the
       <em>
        IntegerExpression
       </em>
       grammar used in the exercise above, which we’ll store in a file called
       <a href="https://github.com/mit6005/sp16-ex18-parser-generators/blob/master/src/intexpr/parser/IntegerExpression.g4">
        <code>
         IntegerExpression.g4
        </code>
       </a>
       .  Antlr 4 grammar files end with
       <code>
        .g4
       </code>
       by convention.
      </p>
      <p>
       The Antlr parser generator tool converts a grammar source file like
       <code>
        IntegerExpression.g4
       </code>
       into Java classes that implement a parser.  To do that, you need to go to a command prompt (Terminal or Command Prompt) and run a command like this:
      </p>
      <pre><code class="language-none">cd &lt;root of project&gt;
cd src/intexpr/parser
java -jar ../../../lib/antlr.jar IntegerExpression.g4</code></pre>
      <p>
       You need to make sure you
       <code>
        cd
       </code>
       into right folder (where
       <code>
        IntegerExpression.g4
       </code>
       is) and you refer to
       <code>
        antlr.jar
       </code>
       where it is in your project folder structure, using a relative path like
       <code>
        ../../../lib/antlr.jar
       </code>
       ).
      </p>
      <p>
       Assuming you don’t have any syntax errors in your grammar file, the parser generator will produce new Java source files in the current folder. Nothing will be printed in the terminal. The generated code is divided into several cooperating modules:
      </p>
      <ul>
       <li>
        the
        <strong>
         lexer
        </strong>
        takes a stream of characters as input, and produces a stream of terminals (Antlr calls them
        <em>
         tokens
        </em>
        ) as output, like
        <code>
         NUMBER
        </code>
        ,
        <code>
         +
        </code>
        , and
        <code>
         (
        </code>
        .  For
        <code>
         IntegerExpression.g4
        </code>
        , the generated lexer is called
        <code>
         IntegerExpressionLexer.java
        </code>
        .
       </li>
       <li>
        the
        <strong>
         parser
        </strong>
        takes the stream of terminals produced by the lexer and produces a parse tree.  The generated parser is called
        <code>
         IntegerExpressionParser.java
        </code>
        .
       </li>
       <li>
        the
        <strong>
         tree walker
        </strong>
        lets you write code that walks over the parse tree produced by the parser, as explained below.  The generated tree walker files are the interface
        <code>
         IntegerExpressionListener.java
        </code>
        , and an empty implementation of the interface,
        <code>
         IntegerExpressionBaseListener.java
        </code>
        .
       </li>
      </ul>
      <p>
       Antlr also generates two text files,
       <code>
        IntegerExpression.tokens
       </code>
       and
       <code>
        IntegerExpressionLexer.tokens
       </code>
       , that list the terminals that Antlr found in your grammar.  These aren’t needed for a simple parser, but they’re needed when you include grammars inside other grammars.
      </p>
      <p>
       Make sure that you:
      </p>
      <ul>
       <li>
        <strong>
         Never edit the files generated by Antlr.
        </strong>
        The right way to change your parser is to edit the grammar source file,
        <code>
         IntegerExpression.g4
        </code>
        , and then regenerate the Java classes.
       </li>
       <li>
        <strong>
         Regenerate the files whenever you edit the grammar file.
        </strong>
        This is easy to forget when Eclipse is compiling all your Java source files automatically.  Eclipse does not regenerate your parser automatically.  Make sure you rerun the
        <code>
         java -jar ...
        </code>
        command whenever you change your .g4 file.
       </li>
       <li>
        <strong>
         Refresh your project in Eclipse each time you regenerate the files.
        </strong>
        You can do this by clicking on your project in Eclipse and pressing F5, or right-clicking and choosing Refresh. The reason is that Eclipse sometimes uses older versions of files already part of the source, even if they have been modified on your filesystem.
       </li>
      </ul>
      <p>
       More about using the Antlr parser generator to produce a parser can be found in Chapter 3 of the
       <a href="https://www.google.com/search?q=The+Definitive+Antlr+4+Reference">
        Definitive ANTLR 4 Reference
       </a>
       .
      </p>
     </div>
     <h2 id="calling_the_parser">
      Calling the parser
     </h2>
     <div data-outline="calling_the_parser">
      <p>
       Now that you’ve generated the Java classes for your parser, you’ll want to use them from your own code.
      </p>
      <p>
       First we need to make a stream of characters to feed to the lexer.  Antlr has a class
       <code>
        ANTLRInputStream
       </code>
       that makes this easy.  It can take a
       <code>
        String
       </code>
       , or a
       <code>
        Reader
       </code>
       , or an
       <code>
        InputStream
       </code>
       as input.  Here we are using a string:
      </p>
      <pre><code class="language-java hljs">CharStream stream = <span class="hljs-keyword">new</span> ANTLRInputStream(<span class="hljs-string">"54+(2+89)"</span>);</code></pre>
      <p>
       Next, we create an instance of the lexer class that our grammar file generated, and pass it the character stream:
      </p>
      <pre><code class="language-java hljs">IntegerExpressionLexer lexer = <span class="hljs-keyword">new</span> IntegerExpressionLexer(stream);
TokenStream tokens = <span class="hljs-keyword">new</span> CommonTokenStream(lexer);</code></pre>
      <p>
       The result is a stream of terminals, which we can then feed to the parser:
      </p>
      <pre><code class="language-java hljs">IntegerExpressionParser parser = <span class="hljs-keyword">new</span> IntegerExpressionParser(tokens);</code></pre>
      <p>
       To actually do the parsing, we call a particular nonterminal on the parser.  The generated parser has one method for every nonterminal in our grammar, including
       <code>
        root()
       </code>
       ,
       <code>
        sum()
       </code>
       , and
       <code>
        primitive()
       </code>
       .  We want to call the nonterminal that represents the set of strings that we want to match – in this case,
       <code>
        root()
       </code>
       .
      </p>
      <div class="panel panel-figure pull-right pull-margin">
       <img alt="the parse tree produced by parsing the expression" src="figures/intexpr-parse-tree.png" width="220px"/>
      </div>
      <p>
       Calling it produces a parse tree:
      </p>
      <pre><code class="language-java hljs">ParseTree tree = parser.root();</code></pre>
      <p>
       For debugging, we can then print this tree out:
      </p>
      <pre><code class="language-java hljs">System.err.println(tree.toStringTree(parser));</code></pre>
      <p>
       Or we can display it in a handy graphical form:
      </p>
      <pre><code class="language-java hljs">Trees.inspect(tree, parser);</code></pre>
      <p>
       which pops up a window with the parse tree shown on the right.
      </p>
      <div class="handout-solo alert alert-warning">
       <p>
        In the example code:
        <a class="alert-link" href="https://github.com/mit6005/sp16-ex18-parser-generators/blob/master/src/intexpr/Main.java#L34-L50">
         <code>
          Main.java
         </code>
         lines 34-50
        </a>
        , which use
        <a class="alert-link" href="https://github.com/mit6005/sp16-ex18-parser-generators/blob/master/src/intexpr/Main.java#L71-L85">
         lines 71-85
        </a>
        .
       </p>
      </div>
     </div>
     <h2 id="traversing_the_parse_tree">
      Traversing the parse tree
     </h2>
     <div data-outline="traversing_the_parse_tree">
      <p>
       So we’ve used the parser to turn a stream of characters into a parse tree, which shows how the grammar matches the stream.
Now we need to do something with this parse tree.
We’re going to translate it into a value of a recursive abstract data type.
      </p>
      <p>
       The first step is to learn how to traverse the parse tree.
To do this, we use a
       <code>
        ParseTreeWalker
       </code>
       , which is an Antlr class that walks over a parse tree, visiting every node in order, top-to-bottom, left-to-right.
As it visits each node in the tree, the walker calls methods on a
       <em>
        listener
       </em>
       object that we provide, which implements
       <code>
        IntegerExpressionListener
       </code>
       interface.
      </p>
      <p>
       Just to warm up, here’s a simple implementation of
       <code>
        IntegerExpressionListener
       </code>
       that just prints a message every time the walker calls us, so we can see how it gets used:
      </p>
      <div class="pull-margin">
       <div class="handout-solo alert alert-warning">
        <p>
         <a class="alert-link" href="https://github.com/mit6005/sp16-ex18-parser-generators/blob/master/src/intexpr/Main.java#L88-L120">
          <code>
           Main.java
          </code>
          line 88
         </a>
        </p>
       </div>
       <pre><code class="language-java hljs"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrintEverything</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IntegerExpressionListener</span> </span>{

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enterRoot</span><span class="hljs-params">(IntegerExpressionParser.RootContext context)</span> </span>{
        System.err.println(<span class="hljs-string">"entering root"</span>);
    }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exitRoot</span><span class="hljs-params">(IntegerExpressionParser.RootContext context)</span> </span>{
        System.err.println(<span class="hljs-string">"exiting root"</span>);
    }

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enterSum</span><span class="hljs-params">(IntegerExpressionParser.SumContext context)</span> </span>{
        System.err.println(<span class="hljs-string">"entering sum"</span>);
    }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exitSum</span><span class="hljs-params">(IntegerExpressionParser.SumContext context)</span> </span>{
        System.err.println(<span class="hljs-string">"exiting sum"</span>);
    }

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enterPrimitive</span><span class="hljs-params">(IntegerExpressionParser.PrimitiveContext context)</span> </span>{
        System.err.println(<span class="hljs-string">"entering primitive"</span>);
    }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exitPrimitive</span><span class="hljs-params">(IntegerExpressionParser.PrimitiveContext context)</span> </span>{
        System.err.println(<span class="hljs-string">"exiting primitive"</span>);
    }

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTerminal</span><span class="hljs-params">(TerminalNode terminal)</span> </span>{
        System.err.println(<span class="hljs-string">"terminal "</span> + terminal.getText());            
    }

    <span class="hljs-comment">// don't need these here, so just make them empty implementations</span>
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enterEveryRule</span><span class="hljs-params">(ParserRuleContext context)</span> </span>{ }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exitEveryRule</span><span class="hljs-params">(ParserRuleContext context)</span> </span>{ }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitErrorNode</span><span class="hljs-params">(ErrorNode node)</span> </span>{ }         
}</code></pre>
      </div>
      <p>
       Notice that every nonterminal
       <code>
        N
       </code>
       in the grammar has corresponding
       <code>
        enterN()
       </code>
       and
       <code>
        exitN()
       </code>
       methods in the listener interface, which are called when the tree walk enters and exits a parse tree node for nonterminal
       <code>
        N
       </code>
       , respectively.
There is also a
       <code>
        visitTerminal()
       </code>
       that is called when the walk reaches a leaf of the parse tree.
Each of these methods has a parameter that provides information about the nonterminal or terminal node that the walk is currently visiting.
      </p>
      <p>
       The listener interface also has some methods that we don’t need.
The methods
       <code>
        enterEveryRule()
       </code>
       and
       <code>
        exitEveryRule()
       </code>
       are called on entering and exiting
       <em>
        any
       </em>
       nonterminal node, in case we want some generic behavior.
The method
       <code>
        visitErrorNode()
       </code>
       is called if the input contained a syntax error that produced an error node in the parse tree.
In the parser we’re writing, however, a syntax error causes an exception to be thrown, so we won’t see any parse trees with error nodes in them.
The interface requires us to implement these methods, but we can just leave their method bodies empty.
      </p>
      <div class="pull-margin">
       <div class="handout-solo alert alert-warning">
        <p>
         <a class="alert-link" href="https://github.com/mit6005/sp16-ex18-parser-generators/blob/master/src/intexpr/Main.java#L53">
          <code>
           Main.java
          </code>
          line 53
         </a>
        </p>
       </div>
       <pre><code class="language-java hljs">ParseTreeWalker walker = <span class="hljs-keyword">new</span> ParseTreeWalker();
IntegerExpressionListener listener = <span class="hljs-keyword">new</span> PrintEverything();
walker.walk(listener, tree);</code></pre>
      </div>
      <p>
       If we walk over the parse tree with this listener, then we see the following output:
      </p>
      <div class="panel panel-figure pull-right pull-margin">
       <img alt="how the ParseTreeWalker walks over the parse tree" src="figures/intexpr-parse-tree.png" width="220px"/>
      </div>
      <pre><code class="language-none">entering root
entering sum
entering primitive
terminal 54
exiting primitive
terminal +
entering primitive
terminal (
entering sum
entering primitive
terminal 2
exiting primitive
terminal +
entering primitive
terminal 89
exiting primitive
exiting sum
terminal )
exiting primitive
exiting sum
terminal &lt;EOF&gt;
exiting root</code></pre>
      <p>
       Compare this printout with the parse tree shown at the right, and you’ll see that the
       <code>
        ParseTreeWalker
       </code>
       is stepping through the nodes of the tree in order, from parents to children, and from left to right through the siblings.
      </p>
     </div>
     <h2 id="constructing_an_abstract_syntax_tree">
      Constructing an abstract syntax tree
     </h2>
     <div data-outline="constructing_an_abstract_syntax_tree">
      <p>
       We need to convert the parse tree into a recursive data type.
Here’s the definition of the recursive data type that we’re going to use to represent integer arithmetic expressions:
      </p>
      <pre><code class="language-python hljs">IntegerExpression = Number(n:int)
                    + Plus(left:IntegerExpression, right:IntegerExpression)</code></pre>
      <p>
       If this syntax is mysterious, review
       <a href="../16-recursive-data-types/recursive/index.html#recursive_datatype_definitions">
        recursive data type definitions
       </a>
       .
      </p>
      <p>
       When a recursive data type represents a language this way, it is often called an
       <em>
        abstract syntax tree
       </em>
       .  A
       <a href="https://github.com/mit6005/sp16-ex18-parser-generators/blob/master/src/intexpr/IntegerExpression.java">
        <code>
         IntegerExpression
        </code>
       </a>
       value captures the important features of the expression – its grouping and the integers in it – while omitting unnecessary details of the sequence of characters that created it.
      </p>
      <p>
       By contrast, the parse tree that we just generated with the
       <em>
        IntegerExpression
       </em>
       parser is a
       <em>
        concrete syntax tree
       </em>
       .  It’s called concrete, rather than abstract, because it contains more details about how the expression is represented in actual characters.  For example, the strings
       <code>
        2+2
       </code>
       ,
       <code>
        ((2)+(2))
       </code>
       , and
       <code>
        0002+0002
       </code>
       would each produce a different concrete syntax tree, but these trees would all correspond to the same abstract
       <code>
        IntegerExpression
       </code>
       value:
       <code>
        Plus(Number(2), Number(2))
       </code>
       .
      </p>
      <p>
       Now we create a listener that constructs a
       <code>
        IntegerExpression
       </code>
       tree while it’s walking over the parse tree.  Each parse tree node will correspond to a
       <code>
        IntegerExpression
       </code>
       variant:
       <code>
        sum
       </code>
       nodes will create
       <a href="https://github.com/mit6005/sp16-ex18-parser-generators/blob/master/src/intexpr/IntegerExpression.java#L36">
        <code>
         Plus
        </code>
       </a>
       objects, and
       <code>
        primitive
       </code>
       nodes (that matched the
       <code>
        NUMBER
       </code>
       terminal) will create
       <a href="https://github.com/mit6005/sp16-ex18-parser-generators/blob/master/src/intexpr/IntegerExpression.java#L12">
        <code>
         Number
        </code>
       </a>
       objects.
      </p>
      <p>
       Some
       <code>
        primitive
       </code>
       nodes are parenthesized subexpressions, not numbers. For these nodes, our listener will construct no new
       <code>
        IntegerExpression
       </code>
       object at all. Parentheses are concrete syntax whose meaning is captured in the abstract syntax tree by the structure of
       <code>
        Plus
       </code>
       and
       <code>
        Number
       </code>
       objects, and we already have a
       <code>
        Plus
       </code>
       to represent the
       <code>
        sum
       </code>
       inside the parentheses.
      </p>
      <p>
       Whenever the walker exits each node of the parse tree, we have walked over the entire subtree under that node, so we create the next
       <code>
        IntegerExpression
       </code>
       object at exit time.  But we have to keep track of all the children that were created during the walk over that subtree.  We use a stack to store them.
      </p>
      <p>
       Here’s the code:
      </p>
      <div class="pull-margin">
       <div class="handout-solo alert alert-warning">
        <p>
         <a class="alert-link" href="https://github.com/mit6005/sp16-ex18-parser-generators/blob/master/src/intexpr/Main.java#L122-L201">
          <code>
           Main.java
          </code>
          line 122
         </a>
        </p>
       </div>
       <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/** Make a IntegerExpresion value from a parse tree. */</span>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MakeIntegerExpression</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IntegerExpressionListener</span> </span>{
    <span class="hljs-keyword">private</span> Stack&lt;IntegerExpression&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();
    <span class="hljs-comment">// Invariant: stack contains the IntegerExpression value of each parse</span>
    <span class="hljs-comment">// subtree that has been fully-walked so far, but whose parent has not yet</span>
    <span class="hljs-comment">// been exited by the walk. The stack is ordered by recency of visit, so that</span>
    <span class="hljs-comment">// the top of the stack is the IntegerExpression for the most recently walked</span>
    <span class="hljs-comment">// subtree.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// At the start of the walk, the stack is empty, because no subtrees have</span>
    <span class="hljs-comment">// been fully walked.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// Whenever a node is exited by the walk, the IntegerExpression values of its</span>
    <span class="hljs-comment">// children are on top of the stack, in order with the last child on top. To</span>
    <span class="hljs-comment">// preserve the invariant, we must pop those child IntegerExpression values</span>
    <span class="hljs-comment">// from the stack, combine them with the appropriate IntegerExpression</span>
    <span class="hljs-comment">// producer, and push back an IntegerExpression value representing the entire</span>
    <span class="hljs-comment">// subtree under the node.</span>
    <span class="hljs-comment">//</span>
    <span class="hljs-comment">// At the end of the walk, after all subtrees have been walked and the the</span>
    <span class="hljs-comment">// root has been exited, only the entire tree satisfies the invariant's</span>
    <span class="hljs-comment">// "fully walked but parent not yet exited" property, so the top of the stack</span>
    <span class="hljs-comment">// is the IntegerExpression of the entire parse tree.</span>

    <span class="hljs-comment handout-javadoc-comment">/**
     * Returns the expression constructed by this listener object.
     * Requires that this listener has completely walked over an IntegerExpression
     * parse tree using ParseTreeWalker.
     * <span class="hljs-doctag">@return</span> IntegerExpression for the parse tree that was walked
     */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> IntegerExpression <span class="hljs-title">getExpression</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> stack.get(<span class="hljs-number">0</span>);
    }

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exitRoot</span><span class="hljs-params">(IntegerExpressionParser.RootContext context)</span> </span>{
        <span class="hljs-comment">// do nothing, root has only one child so its value is </span>
        <span class="hljs-comment">// already on top of the stack</span>
    }

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exitSum</span><span class="hljs-params">(IntegerExpressionParser.SumContext context)</span> </span>{  
        <span class="hljs-comment">// matched the primitive ('+' primitive)* rule</span>
        List&lt;IntegerExpressionParser.PrimitiveContext&gt; addends = context.primitive();
        <span class="hljs-keyword">assert</span> stack.size() &gt;= addends.size();

        <span class="hljs-comment">// the pattern above always has at least 1 child;</span>
        <span class="hljs-comment">// pop the last child</span>
        <span class="hljs-keyword">assert</span> addends.size() &gt; <span class="hljs-number">0</span>;
        IntegerExpression sum = stack.pop();

        <span class="hljs-comment">// pop the older children, one by one, and add them on</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; addends.size(); ++i) {
            sum = <span class="hljs-keyword">new</span> Plus(stack.pop(), sum);
        }

        <span class="hljs-comment">// the result is this subtree's IntegerExpression</span>
        stack.push(sum);
    }

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exitPrimitive</span><span class="hljs-params">(IntegerExpressionParser.PrimitiveContext context)</span> </span>{
        <span class="hljs-keyword">if</span> (context.NUMBER() != <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">// matched the NUMBER alternative</span>
            <span class="hljs-keyword">int</span> n = Integer.valueOf(context.NUMBER().getText());
            IntegerExpression number = <span class="hljs-keyword">new</span> Number(n);
            stack.push(number);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">// matched the '(' sum ')' alternative</span>
            <span class="hljs-comment">// do nothing, because sum's value is already on the stack</span>
        }
    }

    <span class="hljs-comment">// don't need these here, so just make them empty implementations</span>
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enterRoot</span><span class="hljs-params">(IntegerExpressionParser.RootContext context)</span> </span>{ }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enterSum</span><span class="hljs-params">(IntegerExpressionParser.SumContext context)</span> </span>{ }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enterPrimitive</span><span class="hljs-params">(IntegerExpressionParser.PrimitiveContext context)</span> </span>{ }

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitTerminal</span><span class="hljs-params">(TerminalNode terminal)</span> </span>{ }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enterEveryRule</span><span class="hljs-params">(ParserRuleContext context)</span> </span>{ }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exitEveryRule</span><span class="hljs-params">(ParserRuleContext context)</span> </span>{ }
    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">visitErrorNode</span><span class="hljs-params">(ErrorNode node)</span> </span>{ }         
}</code></pre>
      </div>
      <p>
       More about Antlr’s parse-tree listeners can be found in Section 7.2 of the
       <a href="https://www.google.com/search?q=The+Definitive+Antlr+4+Reference">
        Definitive ANTLR 4 Reference
       </a>
       .
      </p>
     </div>
     <h2 id="handling_errors">
      Handling errors
     </h2>
     <div data-outline="handling_errors">
      <p>
       By default, Antlr parsers print errors to the console.  In order to make the parser modular, however, we need to handle those errors differently.  You can attach an
       <code>
        ErrorListener
       </code>
       to the lexer and parser in order to throw an exception when an error is encountered during parsing.  The
       <code>
        Configuration.g4
       </code>
       file defines a method
       <code>
        reportErrorsAsExceptions()
       </code>
       which does this.  So if you copy the technique used in this grammar file, you can call:
      </p>
      <pre><code class="language-java hljs">lexer.reportErrorsAsExceptions();
parser.reportErrorsAsExceptions();</code></pre>
      <p>
       right after you create the lexer and parser.  Then when you call
       <code>
        parser.root()
       </code>
       , it will throw an exception as soon as it encounters something that it can’t match.
      </p>
      <p>
       This is a simplistic approach to handling errors.  Antlr offers more sophisticated forms of error recovery as well.  To learn more, see Chapter 9 in the
       <a href="https://www.google.com/search?q=The+Definitive+Antlr+4+Reference">
        Definitive Antlr 4 Reference
       </a>
       .
      </p>
     </div>
     <h2 id="summary">
      Summary
     </h2>
     <div data-outline="summary">
      <p>
       The topics of today’s reading connect to our three properties of good software as follows:
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Safe from bugs.
         </strong>
         A grammar is a declarative specification for strings and streams, which can be implemented automatically by a parser generator.  These specifications are often simpler, more direct, and less likely to be buggy then parsing code written by hand.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Easy to understand.
         </strong>
         A grammar captures the shape of a sequence in a form that is compact and easier to understand than hand-written parsing code.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Ready for change.
         </strong>
         A grammar can be easily edited, then run through a parser generator to regenerate the parsing code.
        </p>
       </li>
      </ul>
     </div>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/18-parser-generators/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:36:06 GMT -->
</html>
<!-- Handout delivered Tue Mar 15 2016 23:03:35 GMT-0400 (EDT) -->
