<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/08-avoiding-debugging/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:45 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 8: Avoiding Debugging
   </title>
   <link href="../../web/handout-style.css" rel="stylesheet">
    <style>
     .indented { margin-left: 40px; }
    </style>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_8_avoiding_debugging">
      Reading 8: Avoiding Debugging
     </a>
    </li>
    <li>
     <a href="#first_defense_make_bugs_impossible">
      First Defense: Make Bugs Impossible
     </a>
    </li>
    <li>
     <a href="#second_defense_localize_bugs">
      Second Defense: Localize Bugs
     </a>
    </li>
    <li>
     <a href="#assertions">
      Assertions
     </a>
    </li>
    <li>
     <a href="#what_to_assert">
      What to Assert
     </a>
    </li>
    <li>
     <a href="#what_not_to_assert">
      What Not to Assert
     </a>
    </li>
    <li>
     <a href="#incremental_development">
      Incremental Development
     </a>
    </li>
    <li>
     <a href="#modularity_encapsulation">
      Modularity &amp; Encapsulation
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_8_avoiding_debugging">
    Reading 8: Avoiding Debugging
   </h1>
   <div data-outline="reading_8_avoiding_debugging">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <h4>
      6.005 Prime Objective
     </h4>
     <table class="table table-striped no-markdown">
      <tbody>
       <tr>
        <th width="33%">
         Safe from bugs
        </th>
        <th>
         Easy to understand
        </th>
        <th>
         Ready for change
        </th>
       </tr>
       <tr>
        <td>
         Correct today and correct in the unknown future.
        </td>
        <td>
         Communicating clearly with future programmers, including future you.
        </td>
        <td>
         Designed to accommodate change without rewriting.
        </td>
       </tr>
      </tbody>
     </table>
     <h4>
      Objectives
     </h4>
     <p>
      The topic of today’s class is debugging – or rather, how to avoid debugging entirely, or keep it easy when you have to do it.
     </p>
     <h2 id="first_defense_make_bugs_impossible">
      First Defense: Make Bugs Impossible
     </h2>
     <div data-outline="first_defense_make_bugs_impossible">
      <p>
       The best defense against bugs is to make them impossible by design.
      </p>
      <p>
       One way that we’ve already talked about is
       <strong>
        <a href="../01-static-checking/index.html#static_checking_dynamic_checking_no_checking">
         static checking
        </a>
       </strong>
       .
Static checking eliminates many bugs by catching them at compile time.
      </p>
      <p>
       We also saw some examples of
       <strong>
        dynamic checking
       </strong>
       in earlier class meetings.
For example, Java makes array overflow bugs impossible by catching them dynamically.
If you try to use an index outside the bounds of an array or a List, then Java automatically produces an error.
Older languages like C and C++ silently allow the bad access, which leads to bugs and
       <a href="http://en.wikipedia.org/wiki/Buffer_overflow">
        security vulnerabilities
       </a>
       .
      </p>
      <p>
       <strong>
        Immutability
       </strong>
       (immunity from change) is another design principle that prevents bugs. 
An
       <em>
        immutable type
       </em>
       is a type whose values can never change once they have been created.
      </p>
      <p>
       String is an immutable type.
There are no methods that you can call on a String that will change the sequence of characters that it represents.
Strings can be passed around and shared without fear that they will be modified by other code.
      </p>
      <p>
       Java also gives us
       <em>
        immutable references
       </em>
       : variables declared with the keyword
       <code>
        final
       </code>
       , which can be assigned once but never reassigned.
It’s good practice to use
       <code>
        final
       </code>
       for declaring the parameters of a method and as many local variables as possible.
Like the type of the variable, these declarations are important documentation, useful to the reader of the code and statically checked by the compiler.
      </p>
      <p>
       Consider this example:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span>[] vowels = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] { <span class="hljs-string">'a'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'o'</span>, <span class="hljs-string">'u'</span> };</code></pre>
      <p>
       The
       <code>
        vowels
       </code>
       variable is declared final, but is it really unchanging?  Which of the following statements will be illegal (caught statically by the compiler), and which will be allowed?
      </p>
      <pre><code class="language-java hljs">vowels = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] { <span class="hljs-string">'x'</span>, <span class="hljs-string">'y'</span>, <span class="hljs-string">'z'</span> }; 
vowels[<span class="hljs-number">0</span>] = <span class="hljs-string">'z'</span>;</code></pre>
      <p>
       You’ll find the answers in the exercise below.  Be careful about what
       <code>
        final
       </code>
       means!  It only makes the
       <em>
        reference
       </em>
       immutable, not necessarily the
       <em>
        object
       </em>
       that the reference points to.
      </p>
     </div>
     <h2 id="second_defense_localize_bugs">
      Second Defense: Localize Bugs
     </h2>
     <div data-outline="second_defense_localize_bugs">
      <p>
       If we can’t prevent bugs, we can try to localize them to a small part of the program, so that we don’t have to look too hard to find the cause of a bug.
When localized to a single method or small module, bugs may be found simply by studying the program text.
      </p>
      <p>
       We already talked about
       <strong>
        fail fast
       </strong>
       : the earlier a problem is observed (the closer to its cause), the easier it is to fix.
      </p>
      <p>
       Let’s begin with a simple example:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/**
 * <span class="hljs-doctag">@param</span> x  requires x &gt;= 0
 * <span class="hljs-doctag">@return</span> approximation to square root of x
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>{ ... }</code></pre>
      <p>
       Now suppose somebody calls
       <code>
        sqrt
       </code>
       with a negative argument.
What’s the best behavior for
       <code>
        sqrt
       </code>
       ?
Since the caller has failed to satisfy the requirement that
       <code>
        x
       </code>
       should be nonnegative,
       <code>
        sqrt
       </code>
       is no longer bound by the terms of its contract, so it is technically free to do whatever it wants: return an arbitrary value, or enter an infinite loop, or melt down the CPU.
Since the bad call indicates a bug in the caller, however, the most useful behavior would point out the bug as early as possible.
We do this by inserting a runtime assertion that tests the precondition.
Here is one way we might write the assertion:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/**
 * <span class="hljs-doctag">@param</span> x  requires x &gt;= 0
 * <span class="hljs-doctag">@return</span> approximation to square root of x
 */</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>{ 
    <span class="hljs-keyword">if</span> (! (x &gt;= <span class="hljs-number">0</span>)) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AssertionError();
    ...
}</code></pre>
      <p>
       When the precondition is not satisfied, this code terminates the program by throwing an
       <code>
        AssertionError
       </code>
       exception.
The effects of the caller’s bug are prevented from propagating.
      </p>
      <p>
       Checking preconditions is an example of
       <strong>
        defensive programming
       </strong>
       .
Real programs are rarely bug-free.
Defensive programming offers a way to mitigate the effects of bugs even if you don’t know where they are.
      </p>
     </div>
     <h2 id="assertions">
      Assertions
     </h2>
     <div data-outline="assertions">
      <p>
       It is common practice to define a procedure for these kinds of defensive checks, usually called
       <code>
        assert
       </code>
       :
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">assert</span> (x &gt;= <span class="hljs-number">0</span>);</code></pre>
      <p>
       This approach abstracts away from what exactly happens when the assertion fails.
The failed assert might exit; it might record an event in a log file; it might email a report to a maintainer.
      </p>
      <p>
       Assertions have the added benefit of documenting an assumption about the state of the program at that point.
To somebody reading your code,
       <code>
        assert (x &gt;= 0)
       </code>
       says “at this point, it should always be true that x &gt;= 0.”
Unlike a comment, however, an assertion is executable code that enforces the assumption at runtime.
      </p>
      <p>
       In Java, runtime assertions are a built-in feature of the language.
The simplest form of the assert statement takes a boolean expression, exactly as shown above, and throws
       <code>
        AssertionError
       </code>
       if the boolean expression evaluates to false:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">assert</span> x &gt;= <span class="hljs-number">0</span>;</code></pre>
      <p>
       An assert statement may also include a description expression, which is usually a string, but may also be a primitive type or a reference to an object.
The description is printed in an error message when the assertion fails, so it can be used to provide additional details to the programmer about the cause of the failure.
The description follows the asserted expression, separated by a colon. For example:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">assert</span> (x &gt;= <span class="hljs-number">0</span>) : <span class="hljs-string">"x is "</span> + x;</code></pre>
      <p>
       If x == -1, then this assertion fails with the error message
      </p>
      <blockquote>
       <p>
        <code>
         x is -1
        </code>
       </p>
      </blockquote>
      <p>
       along with a stack trace that tells you where the assert statement was found in your code and the sequence of calls that brought the program to that point.
This information is often enough to get started in finding the bug.
      </p>
      <p>
       <strong>
        A serious problem with Java assertions is that assertions are
        <em>
         off by default
        </em>
        .
       </strong>
      </p>
      <p>
       If you just run your program as usual, none of your assertions will be checked!
Java’s designers did this because checking assertions can sometimes be costly to performance. 
For most applications, however, assertions are
       <em>
        not
       </em>
       expensive compared to the rest of the code, and the benefit they provide in bug-checking is worth that small cost in peformance.
      </p>
      <p>
       So you have to enable assertions explicity by passing
       <code>
        -ea
       </code>
       (which stands for
       <em>
        enable assertions
       </em>
       ) to the Java virtual machine.
In Eclipse, you enable assertions by going to Run →  Run Configurations →  Arguments, and putting -ea in the VM arguments box.
It’s best, in fact, to enable them by default by going to Preferences → Java → Installed JREs → Edit → Default VM Arguments, as you hopefully did in the
       <a href="../../getting-started/index.html#config-eclipse">
        Getting Started
       </a>
       instructions.
      </p>
      <p>
       It’s always a good idea to have assertions turned on when you’re running JUnit tests.
You can ensure that assertions are enabled using the following test case:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-meta">@Test</span>(expected=AssertionError.class)
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAssertionsEnabled</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">assert</span> <span class="hljs-keyword">false</span>;
}</code></pre>
      <p>
       If assertions are turned on as desired, then
       <code>
        assert false
       </code>
       throws an
       <code>
        AssertionError
       </code>
       .
The annotation
       <code>
        (expected=AssertionError.class)
       </code>
       on the test expects and requires this error to be thrown, so the test passes.
If assertions are turned off, however, then the body of the test will do nothing, failing to throw the expected exception, and JUnit will mark the test as failing.
      </p>
      <p>
       Note that the Java
       <code>
        assert
       </code>
       statement is a different mechanism from the JUnit methods
       <code>
        assertTrue()
       </code>
       ,
       <code>
        assertEquals()
       </code>
       , etc.
They all assert a predicate about your code, but are designed for use in different contexts.
The
       <code>
        assert
       </code>
       statement should be used in implementation code, for defensive checks inside the implementation.
JUnit
       <code>
        assert...()
       </code>
       methods should be used in JUnit tests, to check the result of a test.
The
       <code>
        assert
       </code>
       statements don’t run without
       <code>
        -ea
       </code>
       , but the JUnit
       <code>
        assert...()
       </code>
       methods always run.
      </p>
     </div>
     <h2 id="what_to_assert">
      What to Assert
     </h2>
     <div data-outline="what_to_assert">
      <p>
       Here are some things you should assert:
      </p>
      <p>
       <strong>
        Method argument requirements
       </strong>
       , like we saw for
       <code>
        sqrt
       </code>
       .
      </p>
      <p>
       <strong>
        Method return value requirements.
       </strong>
       This kind of assertion is sometimes called a
       <em>
        self check
       </em>
       . For example, the sqrt method might square its result to check whether it is reasonably close to x:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(<span class="hljs-keyword">double</span> x)</span> </span>{
    <span class="hljs-keyword">assert</span> x &gt;= <span class="hljs-number">0</span>;
    <span class="hljs-keyword">double</span> r;
    ... <span class="hljs-comment">// compute result r</span>
    <span class="hljs-keyword">assert</span> Math.abs(r*r - x) &lt; .<span class="hljs-number">0001</span>;
    <span class="hljs-keyword">return</span> r;
}</code></pre>
      <p>
       <strong>
        Covering all cases.
       </strong>
       If a conditional statement or switch does not cover all the possible cases, it is good practice to use an assertion to block the illegal cases:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">switch</span> (vowel) {
  <span class="hljs-keyword">case</span> <span class="hljs-string">'a'</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">'e'</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">'i'</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">'o'</span>:
  <span class="hljs-keyword">case</span> <span class="hljs-string">'u'</span>: <span class="hljs-keyword">return</span> <span class="hljs-string">"A"</span>;
  <span class="hljs-keyword">default</span>: <span class="hljs-keyword">assert</span> <span class="hljs-keyword">false</span>;
}</code></pre>
      <p>
       The assertion in the default clause has the effect of asserting that
       <code>
        vowel
       </code>
       must be one of the five vowel letters.
      </p>
      <p>
       When should you write runtime assertions?
As you write the code, not after the fact.
When you’re writing the code, you have the invariants in mind.
If you postpone writing assertions, you’re less likely to do it, and you’re liable to omit some important invariants.
      </p>
     </div>
     <h2 id="what_not_to_assert">
      What Not to Assert
     </h2>
     <div data-outline="what_not_to_assert">
      <p>
       Runtime assertions are not free.
They can clutter the code, so they must be used judiciously.
Avoid trivial assertions, just as you would avoid uninformative comments.
For example:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-comment">// don't do this:</span>
x = y + <span class="hljs-number">1</span>;
<span class="hljs-keyword">assert</span> x == y+<span class="hljs-number">1</span>;</code></pre>
      <p>
       This assertion doesn’t find bugs in your code.
It finds bugs in the compiler or Java virtual machine, which are components that you should trust until you have good reason to doubt them.
If an assertion is obvious from its local context, leave it out.
      </p>
      <p>
       Never use assertions to test conditions that are external to your program, such as the existence of files, the availability of the network, or the correctness of input typed by a human user.
Assertions test the internal state of your program to ensure that it is within the bounds of its specification.
When an assertion fails, it indicates that the program has run off the rails in some sense, into a state in which it was not designed to function properly.
Assertion failures therefore indicate bugs.
External failures are not bugs, and there is no change you can make to your program in advance that will prevent them from happening.
External failures should be handled using exceptions instead.
      </p>
      <p>
       Many assertion mechanisms are designed so that assertions are executed only during testing and debugging, and turned off when the program is released to users.
Java’s assert statement behaves this way.
The advantage of this approach is that you can write very expensive assertions that would otherwise seriously degrade the performance of your program.
For example, a procedure that searches an array using binary search has a requirement that the array be sorted.
Asserting this requirement requires scanning through the entire array, however, turning an operation that should run in logarithmic time into one that takes linear time.
You should be willing (eager!) to pay this cost during testing, since it makes debugging much easier, but not after the program is released to users.
      </p>
      <p>
       However, disabling assertions in release has a serious disadvantage.
With assertions disabled, a program has far less error checking when it needs it most.
Novice programmers are usually much more concerned about the performance impact of assertions than they should be. 
Most assertions are cheap, so they should not be disabled in the official release.
      </p>
      <p>
       Since assertions may be disabled, the correctness of your program should never depend on whether or not the assertion expressions are executed.
In particular, asserted expressions should not have
       <em>
        side-effects
       </em>
       .
For example, if you want to assert that an element removed from a list was actually found in the list, don’t write it like this:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-comment">// don't do this:</span>
<span class="hljs-keyword">assert</span> list.remove(x);</code></pre>
      <p>
       If assertions are disabled, the entire expression is skipped, and
       <code>
        x
       </code>
       is never removed from the list. Write it like this instead:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">boolean</span> found = list.remove(x);
<span class="hljs-keyword">assert</span> found;</code></pre>
      <div class="handout-solo alert alert-warning">
       <p>
        For 6.005, you are required to have assertions turned on, all the time.  Make sure you did this in Eclipse, following the instructions in the
        <a class="alert-link" href="../../getting-started/index.html#config-eclipse">
         Getting Started handout
        </a>
        .  If you don’t have assertions turned on, you will be sad, and the staff won’t have much sympathy.
       </p>
      </div>
     </div>
     <h2 id="incremental_development">
      Incremental Development
     </h2>
     <div data-outline="incremental_development">
      <p>
       A great way to localize bugs to a tiny part of the program is incremental development.
Build only a bit of your program at a time, and test that bit thoroughly before you move on.
That way, when you discover a bug, it’s more likely to be in the part that you just wrote, rather than anywhere in a huge pile of code.
      </p>
      <p>
       Our class on testing talked about two techniques that help with this:
      </p>
      <ul>
       <li>
        <a href="../03-testing/index.html#unit_testing_and_stubs">
         <strong>
          Unit testing
         </strong>
        </a>
        : when you test a module in isolation, you can be confident that any bug you find is in that unit – or maybe in the test cases themselves.
       </li>
       <li>
        <a href="../03-testing/index.html#automated_testing_and_regression_testing">
         <strong>
          Regression testing
         </strong>
        </a>
        : when you’re adding a new feature to a big system, run the regression test suite as often as possible.  If a test fails, the bug is probably in the code you just changed.
       </li>
      </ul>
     </div>
     <h2 id="modularity_encapsulation">
      Modularity &amp; Encapsulation
     </h2>
     <div data-outline="modularity_encapsulation">
      <p>
       You can also localize bugs by better software design.
      </p>
      <p>
       <strong>
        Modularity.
       </strong>
       Modularity means dividing up a system into components, or modules, each of which can be designed, implemented, tested, reasoned about, and reused separately from the rest of the system.
The opposite of a modular system is a monolithic system – big and with all of its pieces tangled up and dependent on each other.
      </p>
      <p>
       A program consisting of a single, very long main() function is monolithic – harder to understand, and harder to isolate bugs in.
By contrast, a program broken up into small functions and classes is more modular.
      </p>
      <p>
       <strong>
        Encapsulation.
       </strong>
       Encapsulation means building walls around a module (a hard shell or capsule) so that the module is responsible for its own internal behavior, and bugs in other parts of the system can’t damage its integrity.
      </p>
      <p>
       One kind of encapsulation is
       <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">
        access control
       </a>
       , using
       <code>
        public
       </code>
       and
       <code>
        private
       </code>
       to control the visibility and accessibility of your variables and methods.
A public variable or method can be accessed by any code (assuming the class containing that variable or method is also public).
A private variable or method can only be accessed by code in the same class.
Keeping things private as much as possible, especially for variables, provides encapsulation, since it limits the code that could inadvertently cause bugs.
      </p>
      <p>
       Another kind of encapsulation comes from
       <strong>
        variable scope
       </strong>
       .
The
       <em>
        scope
       </em>
       of a variable is the portion of the program text over which that variable is defined, in the sense that expressions and statements can refer to the variable.
A method parameter’s scope is the body of the method.
A local variable’s scope extends from its declaration to the next closing curly brace. 
Keeping variable scopes as small as possible makes it much easier to reason about where a bug might be in the program.
For example, suppose you have a loop like this:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {
    ...
    doSomeThings();
    ...
}</code></pre>
      <p>
       …and you’ve discovered that this loop keeps running forever –
       <code>
        i
       </code>
       never reaches 100.  Somewhere, somebody is changing
       <code>
        i
       </code>
       .
But where?
If
       <code>
        i
       </code>
       is declared as a global variable like this:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i;
...
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {
    ...
    doSomeThings();
    ...
}</code></pre>
      <p>
       …then its scope is the entire program.
It might be changed anywhere in your program: by
       <code>
        doSomeThings()
       </code>
       , by some other method that
       <code>
        doSomeThings()
       </code>
       calls, by a concurrent thread running some completely different code.
But if
       <code>
        i
       </code>
       is instead declared as a local variable with a narrow scope, like this:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {
    ...
    doSomeThings();
    ...
}</code></pre>
      <p>
       …then the only place where
       <code>
        i
       </code>
       can be changed is within the for statement – in fact, only in the … parts that we’ve omitted.
You don’t even have to consider
       <code>
        doSomeThings()
       </code>
       , because
       <code>
        doSomeThings()
       </code>
       doesn’t have access to this local variable.
      </p>
      <p>
       <strong>
        Minimizing the scope of variables
       </strong>
       is a powerful practice for bug localization.
Here are a few rules that are good for Java:
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Always declare a loop variable in the for-loop initializer.
         </strong>
         So rather than declaring it before the loop:
        </p>
        <pre><code class="language-java hljs"><span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {</code></pre>
        <p>
         which makes the scope of the variable the entire rest of the outer curly-brace block containing this code, you should do this:
        </p>
        <pre><code class="language-java hljs"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i) {</code></pre>
        <p>
         which makes the scope of
         <code>
          i
         </code>
         limited just to the for loop.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Declare a variable only when you first need it, and in the innermost curly-brace block that you can.
         </strong>
         Variable scopes in Java are curly-brace blocks, so put your variable declaration in the innermost one that contains all the expressions that need to use the variable.
Don’t declare all your variables at the start of the function – it makes their scopes unnecessarily large.
But note that in languages without static type declarations, like Python and Javascript, the scope of a variable is normally the entire function anyway, so you can’t restrict the scope of a variable with curly braces, alas.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Avoid global variables.
         </strong>
         Very bad idea, especially as programs get large.
Global variables are often used as a shortcut to provide a parameter to several parts of your program.
It’s better to just pass the parameter into the code that needs it, rather than putting it in global space where it can inadvertently reassigned.
        </p>
       </li>
      </ul>
      <h3 id="summary">
       Summary
      </h3>
      <div data-outline="summary">
       <p>
        In this reading, we looked at some ways to minimize the cost of debugging:
       </p>
       <ul>
        <li>
         Avoid debugging
         <ul>
          <li>
           make bugs impossible with techniques like static typing, automatic dynamic checking, and immutable types and references
          </li>
         </ul>
        </li>
        <li>
         Keep bugs confined
         <ul>
          <li>
           failing fast with assertions keeps a bug’s effects from spreading
          </li>
          <li>
           incremental development and unit testing confine bugs to your recent code
          </li>
          <li>
           scope minimization reduces the amount of the program you have to search
          </li>
         </ul>
        </li>
       </ul>
       <p>
        Thinking about our three main measures of code quality:
       </p>
       <ul>
        <li>
         <strong>
          Safe from bugs.
         </strong>
         We’re trying to prevent them and get rid of them.
        </li>
        <li>
         <strong>
          Easy to understand.
         </strong>
         Techniques like static typing, final declarations, and assertions are additional documentation of the assumptions in your code.  Variable scope minimization makes it easier for a reader to understand how the variable is used, because there’s less code to look at.
        </li>
        <li>
         <strong>
          Ready for change.
         </strong>
         Assertions and static typing document the assumptions in an automatically-checkable way, so that when a future programmer changes the code, accidental violations of those assumptions are detected.
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/08-avoiding-debugging/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:45 GMT -->
</html>
<!-- Handout delivered Thu Feb 25 2016 12:33:20 GMT-0500 (EST) -->
