<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/22-queues/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:36:13 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 22: Queues and Message-Passing
   </title>
   <link href="../../web/handout-style.css" rel="stylesheet">
    <style>
     /* links to example code */
.code-container {
  position: relative;
}
.code-container .handout-solo {
  position: absolute; top: 4px; right: 4px; padding: 8px;
}
    </style>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_22_queues_and_message-passing">
      Reading 22: Queues and Message-Passing
     </a>
    </li>
    <li>
     <a href="#two_models_for_concurrency">
      Two models for concurrency
     </a>
    </li>
    <li>
     <a href="#message_passing_with_threads">
      Message passing with threads
     </a>
    </li>
    <li>
     <a href="#implementing_message_passing_with_queues">
      Implementing message passing with queues
     </a>
    </li>
    <li>
     <a href="#stopping">
      Stopping
     </a>
    </li>
    <li>
     <a href="#thread_safety_arguments_with_message_passing">
      Thread safety arguments with message passing
     </a>
    </li>
    <li>
     <a href="#summary">
      Summary
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_22_queues_and_message-passing">
    Reading 22: Queues and Message-Passing
   </h1>
   <div data-outline="reading_22_queues_and_message-passing">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <h4>
      Software in 6.005
     </h4>
     <table class="table table-striped no-markdown">
      <tbody>
       <tr>
        <th width="33%">
         Safe from bugs
        </th>
        <th>
         Easy to understand
        </th>
        <th>
         Ready for change
        </th>
       </tr>
       <tr>
        <td>
         Correct today and correct in the unknown future.
        </td>
        <td>
         Communicating clearly with future programmers, including future you.
        </td>
        <td>
         Designed to accommodate change without rewriting.
        </td>
       </tr>
      </tbody>
     </table>
     <h4>
      Objectives
     </h4>
     <p>
      After reading the notes and examining the code for this class, you should be able to use message passing (with synchronous queues) instead of shared memory for communication between threads.
     </p>
     <h2 id="two_models_for_concurrency">
      Two models for concurrency
     </h2>
     <div data-outline="two_models_for_concurrency">
      <p>
       In our introduction to concurrency, we saw
       <a href="../19-concurrency/index.html#two_models_for_concurrent_programming">
        two models for concurrent programming
       </a>
       :
       <em>
        shared memory
       </em>
       and
       <em>
        message passing
       </em>
       .
      </p>
      <ul>
       <li>
        <div class="panel panel-figure pull-right pull-margin" style="margin-top:-1em">
         <img alt="multiprocessor shared memory" src="figures/multiprocessor.png" width="200"/>
        </div>
        <p>
         In the
         <strong>
          shared memory
         </strong>
         model, concurrent modules interact by reading and writing shared mutable objects in memory.
Creating multiple threads inside a single Java process is our primary example of shared-memory concurrency.
        </p>
       </li>
       <li>
        <p>
         In the
         <strong>
          message passing
         </strong>
         model, concurrent modules interact by sending immutable messages to one another over a communication channel.
We’ve had one example of message passing so far: the
         <a href="../21-sockets-networking/index.html#clientserver_design_pattern">
          client/server pattern
         </a>
         , in which clients and servers are concurrent processes, often on different machines, and the communication channel is a
         <a href="../21-sockets-networking/index.html#network_sockets">
          network socket
         </a>
         .
        </p>
        <div class="panel panel-figure pull-right pull-margin">
         <img alt="network message passing" src="figures/network.png" width="200"/>
        </div>
       </li>
      </ul>
      <p>
       The message passing model has several advantages over the shared memory model, which boil down to greater safety from bugs.
In message-passing, concurrent modules interact
       <em>
        explicitly
       </em>
       , by passing messages through the communication channel, rather than
       <em>
        implicitly
       </em>
       through mutation of shared data.
The implicit interaction of shared memory can too easily lead to
       <em>
        inadvertent
       </em>
       interaction, sharing and manipulating data in parts of the program that don’t know they’re concurrent and aren’t cooperating properly in the thread safety strategy.
Message passing also shares only immutable objects (the messages) between modules, whereas shared memory
       <em>
        requires
       </em>
       sharing mutable objects, which we have already seen can be
       <a href="../09-immutability/index.html#risks_of_mutation">
        a source of bugs
       </a>
       .
      </p>
      <p>
       We’ll discuss in this reading how to implement message passing within a single process, as opposed to between processes over the network.
We’ll use
       <strong>
        blocking queues
       </strong>
       (an existing threadsafe type) to implement message passing between threads within a process.
      </p>
     </div>
     <h2 id="message_passing_with_threads">
      Message passing with threads
     </h2>
     <div data-outline="message_passing_with_threads">
      <p>
       We’ve previously talked about message passing between processes:
       <a href="../21-sockets-networking/index.html#network_sockets">
        clients and servers communicating over network sockets
       </a>
       .
We can also use message passing between threads within the same process, and this design is often preferable to a shared memory design with locks, which we’ll talk about in the next reading.
      </p>
      <p>
       Use a synchronized queue for message passing between threads.
The queue serves the same function as the buffered network communication channel in client/server message passing.
Java provides the
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/BlockingQueue.html">
        <code>
         BlockingQueue
        </code>
       </a>
       interface for queues with blocking operations:
      </p>
      <p>
       In an ordinary
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/util/Queue.html">
        <code>
         Queue
        </code>
       </a>
       :
      </p>
      <ul>
       <li>
        <code>
         add(e)
        </code>
        adds element
        <code>
         e
        </code>
        to the end of the queue.
       </li>
       <li>
        <code>
         remove()
        </code>
        removes and returns the element at the head of the queue, or throws an exception if the queue is empty.
       </li>
      </ul>
      <p>
       A
       <a href="http://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/BlockingQueue.html">
        <code>
         BlockingQueue
        </code>
       </a>
       extends this interface:
      </p>
      <blockquote>
       <p>
        additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element.
       </p>
      </blockquote>
      <ul>
       <li>
        <strong>
         <code>
          put(e)
         </code>
        </strong>
        <em>
         blocks
        </em>
        until it can add element
        <code>
         e
        </code>
        to the end of the queue (if the queue does not have a size bound,
        <code>
         put
        </code>
        will not block).
       </li>
       <li>
        <strong>
         <code>
          take()
         </code>
        </strong>
        <em>
         blocks
        </em>
        until it can remove and return the element at the head of the queue, waiting until the queue is non-empty.
       </li>
      </ul>
      <p>
       When you are using a
       <code>
        BlockingQueue
       </code>
       for message passing between threads, make sure to use the
       <code>
        put()
       </code>
       and
       <code>
        take()
       </code>
       operations, not
       <strike class="no-markdown">
        <code>
         add()
        </code>
        and
        <code>
         remove()
        </code>
       </strike>
       .
      </p>
      <div class="panel panel-figure pull-right pull-margin">
       <img alt="producer-consumer message passing" src="figures/producer-consumer.png" width="240"/>
      </div>
      <p>
       Analogous to the client/server pattern for message passing over a network is the
       <strong>
        producer-consumer design pattern
       </strong>
       for message passing between threads.
Producer threads and consumer threads share a synchronized queue.
Producers put data or requests onto the queue, and consumers remove and process them.
One or more producers and one or more consumers might all be adding and removing items from the same queue.
This queue must be safe for concurrency.
      </p>
      <p>
       Java provides two implementations of
       <code>
        BlockingQueue
       </code>
       :
      </p>
      <ul>
       <li>
        <a href="http://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/ArrayBlockingQueue.html">
         <code>
          ArrayBlockingQueue
         </code>
        </a>
        is a fixed-size queue that uses an array representation.
        <code>
         put
        </code>
        ting a new item on the queue will block if the queue is full.
       </li>
       <li>
        <a href="http://docs.oracle.com/javase/8/docs/api/?java/util/concurrent/LinkedBlockingQueue.html">
         <code>
          LinkedBlockingQueue
         </code>
        </a>
        is a growable queue using a linked-list representation.
If no maximum capacity is specified, the queue will never fill up, so
        <code>
         put
        </code>
        will never block.
       </li>
      </ul>
      <p>
       Unlike the streams of bytes sent and received by sockets, these synchronized queues (like normal collections classes in Java) can hold objects of an arbitrary type.
Instead of designing a wire protocol, we must choose or design a type for messages in the queue.
       <strong>
        It must be an immutable type.
       </strong>
       And just as we did with operations on a threadsafe ADT or messages in a wire protocol, we must design our messages here to prevent race conditions and enable clients to perform the atomic operations they need.
      </p>
      <h3 id="bank_account_example">
       Bank account example
      </h3>
      <div data-outline="bank_account_example">
       <div class="panel panel-figure pull-right pull-margin">
        <img alt="message passing model for bank accounts" src="figures/message-passing-bank-account.png" width="500"/>
       </div>
       <p>
        Our first example of message passing was the
        <a href="../19-concurrency/index.html#message_passing_example">
         bank account example
        </a>
        .
       </p>
       <p>
        Each cash machine and each account is its own module, and modules interact by sending messages to one another.
Incoming messages arrive on a queue.
       </p>
       <p>
        We designed messages for
        <code>
         get-balance
        </code>
        and
        <code>
         withdraw
        </code>
        , and said that each cash machine checks the account balance before withdrawing to prevent overdrafts:
       </p>
       <pre><code class="hljs bash">get-balance
<span class="hljs-keyword">if</span> balance &gt;= 1 <span class="hljs-keyword">then</span> withdraw 1</code></pre>
       <p>
        But it is still possible to interleave messages from two cash machines so they are both fooled into thinking they can safely withdraw the last dollar from an account with only $1 in it.
       </p>
       <p>
        We need to choose a better atomic operation:
        <code>
         withdraw-if-sufficient-funds
        </code>
        would be a better operation than just
        <code>
         withdraw
        </code>
        .
       </p>
      </div>
     </div>
     <h2 id="implementing_message_passing_with_queues">
      Implementing message passing with queues
     </h2>
     <div data-outline="implementing_message_passing_with_queues">
      <p>
       You can see all the code for this example on GitHub:
       <a href="https://github.com/mit6005/sp16-ex22-square">
        <strong>
         squarer example
        </strong>
       </a>
       .
All the relevant parts are excerpted below.
      </p>
      <p>
       Here’s a message passing module for squaring integers:
      </p>
      <div class="code-container">
       <div class="handout-solo alert alert-warning">
        <p>
         <a class="alert-link" href="https://github.com/mit6005/sp16-ex22-square/blob/master/src/square/SquareQueue.java#L6-L46">
          <code>
           SquareQueue.java
          </code>
          line 6
         </a>
        </p>
       </div>
       <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/** Squares integers. */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Squarer</span> </span>{

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Integer&gt; in;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;SquareResult&gt; out;
    <span class="hljs-comment">// Rep invariant: in, out != null</span>

    <span class="hljs-comment handout-javadoc-comment">/** Make a new squarer.
     *  <span class="hljs-doctag">@param</span> requests queue to receive requests from
     *  <span class="hljs-doctag">@param</span> replies queue to send replies to */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Squarer</span><span class="hljs-params">(BlockingQueue&lt;Integer&gt; requests,
                   BlockingQueue&lt;SquareResult&gt; replies)</span> </span>{
        <span class="hljs-keyword">this</span>.in = requests;
        <span class="hljs-keyword">this</span>.out = replies;
    }

    <span class="hljs-comment handout-javadoc-comment">/** Start handling squaring requests. */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() {
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
                    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> we may want a way to stop the thread</span>
                    <span class="hljs-keyword">try</span> {
                        <span class="hljs-comment">// block until a request arrives</span>
                        <span class="hljs-keyword">int</span> x = in.take();
                        <span class="hljs-comment">// compute the answer and send it back</span>
                        <span class="hljs-keyword">int</span> y = x * x;
                        out.put(<span class="hljs-keyword">new</span> SquareResult(x, y));
                    } <span class="hljs-keyword">catch</span> (InterruptedException ie) {
                        ie.printStackTrace();
                    }
                }
            }
        }).start();
    }
}</code></pre>
      </div>
      <p>
       Incoming messages to the
       <code>
        Squarer
       </code>
       are integers; the squarer knows that its job is to square those numbers, so no further details are required.
      </p>
      <p>
       Outgoing messages are instances of
       <code>
        SquareResult
       </code>
       :
      </p>
      <div class="code-container">
       <div class="handout-solo alert alert-warning">
        <p>
         <a class="alert-link" href="https://github.com/mit6005/sp16-ex22-square/blob/master/src/square/SquareQueue.java#L48-L70">
          <code>
           SquareQueue.java
          </code>
          line 48
         </a>
        </p>
       </div>
       <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/** An immutable squaring result message. */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SquareResult</span> </span>{
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> input;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> output;

    <span class="hljs-comment handout-javadoc-comment">/** Make a new result message.
     *  <span class="hljs-doctag">@param</span> input input number
     *  <span class="hljs-doctag">@param</span> output square of input */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SquareResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> input, <span class="hljs-keyword">int</span> output)</span> </span>{
        <span class="hljs-keyword">this</span>.input = input;
        <span class="hljs-keyword">this</span>.output = output;
    }

    <span class="hljs-meta">@Override</span> <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>{
        <span class="hljs-keyword">return</span> input + <span class="hljs-string">"^2 = "</span> + output;
    }
}</code></pre>
      </div>
      <p>
       We would probably add additional observers to
       <code>
        SquareResult
       </code>
       so clients can retrieve the input number and output result.
      </p>
      <p>
       Finally, here’s a main method that uses the squarer:
      </p>
      <div class="code-container">
       <div class="handout-solo alert alert-warning">
        <p>
         <a class="alert-link" href="https://github.com/mit6005/sp16-ex22-square/blob/master/src/square/SquareQueue.java#L77-L96">
          <code>
           SquareQueue.java
          </code>
          line 77
         </a>
        </p>
       </div>
       <pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>{

    BlockingQueue&lt;Integer&gt; requests = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;();
    BlockingQueue&lt;SquareResult&gt; replies = <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;();

    Squarer squarer = <span class="hljs-keyword">new</span> Squarer(requests, replies);
    squarer.start();

    <span class="hljs-keyword">try</span> {
        <span class="hljs-comment">// make a request</span>
        requests.put(<span class="hljs-number">42</span>);
        <span class="hljs-comment">// ... maybe do something concurrently ...</span>
        <span class="hljs-comment">// read the reply</span>
        System.out.println(replies.take());
    } <span class="hljs-keyword">catch</span> (InterruptedException ie) {
        ie.printStackTrace();
    }
}</code></pre>
      </div>
      <p>
       It should not surprise us that this code has a very similar flavor to the code for implementing message passing with sockets.
      </p>
     </div>
     <h2 id="stopping">
      Stopping
     </h2>
     <div data-outline="stopping">
      <p>
       What if we want to shut down the
       <code>
        Squarer
       </code>
       so it is no longer waiting for new inputs?
In the client/server model, if we want the client or server to stop listening for our messages, we close the socket.
And if we want the client or server to stop altogether, we can quit that process.
But here, the squarer is just another thread in the
       <em>
        same
       </em>
       process, and we can’t “close” a queue.
      </p>
      <p>
       One strategy is a
       <em>
        poison pill
       </em>
       : a special message on the queue that signals the consumer of that message to end its work.
To shut down the squarer, since its input messages are merely integers, we would have to choose a magic poison integer (everyone knows the square of 0 is 0 right? no one will need to ask for the square of 0…) or use null (don’t use null).
Instead, we might change the type of elements on the requests queue to an ADT:
      </p>
      <pre><code class="hljs ini"><span class="hljs-attr">SquareRequest</span> = IntegerRequest + StopRequest
</code></pre>
      <p>
       with operations:
      </p>
      <pre><code class="language-none">input : SquareRequest → int
shouldStop : SquareRequest → boolean</code></pre>
      <p>
       and when we want to stop the squarer, we enqueue a
       <code>
        StopRequest
       </code>
       where
       <code>
        shouldStop
       </code>
       returns
       <code>
        true
       </code>
       .
      </p>
      <p>
       For example, in
       <code>
        Squarer.start()
       </code>
       :
      </p>
      <pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// block until a request arrives</span>
            SquareRequest req = in.take();
            <span class="hljs-comment">// see if we should stop</span>
            <span class="hljs-keyword">if</span> (req.shouldStop()) { <span class="hljs-keyword">break</span>; }
            <span class="hljs-comment">// compute the answer and send it back</span>
            <span class="hljs-keyword">int</span> x = req.input();
            <span class="hljs-keyword">int</span> y = x * x;
            out.put(<span class="hljs-keyword">new</span> SquareResult(x, y));
        } <span class="hljs-keyword">catch</span> (InterruptedException ie) {
            ie.printStackTrace();
        }
    }
}</code></pre>
      <p>
       It is also possible to
       <em>
        interrupt
       </em>
       a thread by calling its
       <code>
        interrupt()
       </code>
       method.
If the thread is blocked waiting, the method it’s blocked in will throw an
       <code>
        InterruptedException
       </code>
       (that’s why we have to try-catch that exception almost any time we call a blocking method).
If the thread was not blocked, an
       <em>
        interrupted
       </em>
       flag will be set.
The thread must check for this flag to see whether it should stop working.
For example:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// handle requests until we are interrupted</span>
    <span class="hljs-keyword">while</span> ( ! Thread.interrupted()) {
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// block until a request arrives</span>
            <span class="hljs-keyword">int</span> x = in.take();
            <span class="hljs-comment">// compute the answer and send it back</span>
            <span class="hljs-keyword">int</span> y = x * x;
            out.put(<span class="hljs-keyword">new</span> SquareResult(x, y));
        } <span class="hljs-keyword">catch</span> (InterruptedException ie) {
            <span class="hljs-comment">// stop</span>
            <span class="hljs-keyword">break</span>;
        }
    }
}</code></pre>
     </div>
     <h2 id="thread_safety_arguments_with_message_passing">
      Thread safety arguments with message passing
     </h2>
     <div data-outline="thread_safety_arguments_with_message_passing">
      <p>
       A thread safety argument with message passing might rely on:
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Existing threadsafe data types
         </strong>
         for the synchronized queue.
This queue is definitely shared and definitely mutable, so we must ensure it is safe for concurrency.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Immutability
         </strong>
         of messages or data that might be accessible to multiple threads at the same time.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Confinement
         </strong>
         of data to individual producer/consumer threads.
Local variables used by one producer or consumer are not visible to other threads, which only communicate with one another using messages in the queue.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Confinement
         </strong>
         of mutable messages or data that are sent over the queue but will only be accessible to one thread at a time.
This argument must be carefully articulated and implemented.
But if one module drops all references to some mutable data like a hot potato as soon as it puts them onto a queue to be delivered to another thread, only one thread will have access to those data at a time, precluding concurrent access.
        </p>
       </li>
      </ul>
      <p>
       In comparison to synchronization, message passing can make it easier for each module in a concurrent system to maintain its own thread safety invariants.
We don’t have to reason about multiple threads accessing shared data if the data are instead transferred between modules using a threadsafe communication channel.
      </p>
     </div>
     <h2 id="summary">
      Summary
     </h2>
     <div data-outline="summary">
      <ul>
       <li>
        <p>
         Rather than synchronize with locks, message passing systems synchronize on a shared communication channel, e.g. a stream or a queue.
        </p>
       </li>
       <li>
        <p>
         Threads communicating with blocking queues is a useful pattern for message passing within a single process.
        </p>
       </li>
      </ul>
     </div>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/22-queues/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:36:18 GMT -->
</html>
<!-- Handout delivered Fri Apr 01 2016 15:56:56 GMT-0400 (EDT) -->
