<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/01-static-checking/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:11 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 1: Static Checking
   </title>
   <link href="../../web/handout-style.css" rel="stylesheet">
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_1_static_checking">
      Reading 1: Static Checking
     </a>
    </li>
    <li>
     <a href="#hailstone_sequence">
      Hailstone Sequence
     </a>
    </li>
    <li>
     <a href="#computing_hailstones">
      Computing Hailstones
     </a>
    </li>
    <li>
     <a href="#types">
      Types
     </a>
    </li>
    <li>
     <a href="#static_typing">
      Static Typing
     </a>
    </li>
    <li>
     <a href="#static_checking_dynamic_checking_no_checking">
      Static Checking, Dynamic Checking, No Checking
     </a>
    </li>
    <li>
     <a href="#surprise_primitive_types_are_not_true_numbers">
      Surprise: Primitive Types Are Not True Numbers
     </a>
    </li>
    <li>
     <a href="#arrays_and_collections">
      Arrays and Collections
     </a>
    </li>
    <li>
     <a href="#iterating">
      Iterating
     </a>
    </li>
    <li>
     <a href="#methods">
      Methods
     </a>
    </li>
    <li>
     <a href="#mutating_values_vs_reassigning_variables">
      Mutating Values vs. Reassigning Variables
     </a>
    </li>
    <li>
     <a href="#documenting_assumptions">
      Documenting Assumptions
     </a>
    </li>
    <li>
     <a href="#hacking_vs_engineering">
      Hacking vs. Engineering
     </a>
    </li>
    <li>
     <a href="#the_goal_of_6005">
      The Goal of 6.005
     </a>
    </li>
    <li>
     <a href="#why_we_use_java_in_this_course">
      Why we use Java in this course
     </a>
    </li>
    <li>
     <a href="#summary">
      Summary
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_1_static_checking">
    Reading 1: Static Checking
   </h1>
   <div data-outline="reading_1_static_checking">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <h4>
      Objectives for Today’s Class
     </h4>
     <p>
      Today’s class has two topics:
     </p>
     <ul>
      <li>
       static typing
      </li>
      <li>
       the big three properties of good software
      </li>
     </ul>
     <h2 id="hailstone_sequence">
      Hailstone Sequence
     </h2>
     <div data-outline="hailstone_sequence">
      <p>
       As a running example, we’re going to explore the hailstone sequence, which is defined as follows.  Starting with a number n, the next number in the sequence is n/2 if n is even, or 3n+1 if n is odd.  The sequence ends when it reaches 1.  Here are some examples:
      </p>
      <pre class="no-markdown">2, 1
3, 10, 5, 16, 8, 4, 2, 1
4, 2, 1
2<sup>n</sup>, 2<sup>n-1</sup> , ... , 4, 2, 1
5, 16, 8, 4, 2, 1
7, 22, 11, 34, 17, 52, 6, 13, 40, ...? (where does this stop?)
</pre>
      <p>
       Because of the odd-number rule, the sequence may bounce up and down before decreasing to 1.  It’s conjectured that all hailstones eventually fall to the ground – i.e., the hailstone sequence reaches 1 for all starting n – but that’s still an
       <a href="https://en.wikipedia.org/wiki/Collatz_conjecture">
        open question
       </a>
       .
Why is it called a hailstone sequence?  Because hailstones form in clouds by bouncing up and down, until they eventually build enough weight to fall to earth.
      </p>
     </div>
     <h2 id="computing_hailstones">
      Computing Hailstones
     </h2>
     <div data-outline="computing_hailstones">
      <p>
       Here’s some code for computing and printing the hailstone sequence for some starting n.  We’ll write Java and Python side by side for comparison:
      </p>
      <table>
       <tbody>
        <tr>
         <td style="vertical-align: top; padding-right: 10px">
          <pre><code class="language-java hljs"><span class="hljs-comment">// Java</span>
<span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>;
<span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) {
    System.out.println(n);
    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        n = n / <span class="hljs-number">2</span>;
    } <span class="hljs-keyword">else</span> {
        n = <span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>;
    }
}
System.out.println(n);</code></pre>
         </td>
         <td style="vertical-align: top">
          <pre><code class="language-python hljs"><span class="hljs-comment"># Python</span>
n = <span class="hljs-number">3</span>
<span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span>:
    <span class="hljs-keyword">print</span> n
    <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:
        n = n / <span class="hljs-number">2</span>
    <span class="hljs-keyword">else</span>:
        n = <span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>


<span class="hljs-keyword">print</span> n</code></pre>
         </td>
        </tr>
       </tbody>
      </table>
      <p>
       A few things are worth noting here:
      </p>
      <ul>
       <li>
        The basic semantics of expressions and statements in Java are very similar to Python:
        <code>
         while
        </code>
        and
        <code>
         if
        </code>
        behave the same, for example.
       </li>
       <li>
        Java requires semicolons at the ends of statements.  The extra punctuation can be a pain, but it also gives you more freedom in how you organize your code – you can split a statement into multiple lines for more readability.
       </li>
       <li>
        Java requires parentheses around the conditions of the
        <code>
         if
        </code>
        and
        <code>
         while
        </code>
        .
       </li>
       <li>
        Java requires curly braces around blocks, instead of indentation.
You should always indent the block, even though Java won’t pay any attention to your extra spaces.  Programming is a form of communication, and you’re communicating not only to the compiler, but to human beings.  Humans need that indentation.  We’ll come back to this later.
       </li>
      </ul>
     </div>
     <h2 id="types">
      Types
     </h2>
     <div data-outline="types">
      <p>
       The most important semantic difference between the Python and Java code above is the declaration of the variable
       <code>
        n
       </code>
       , which specifies its type:
       <code>
        int
       </code>
       .
      </p>
      <p>
       A
       <strong>
        type
       </strong>
       is a set of values, along with operations that can be performed on those values.
      </p>
      <p>
       Java has several
       <strong>
        primitive types
       </strong>
       , among them:
      </p>
      <ul>
       <li>
        <code>
         int
        </code>
        (for integers like 5 and -200, but limited to the range ± 2^31, or roughly ± 2 billion)
       </li>
       <li>
        <code>
         long
        </code>
        (for larger integers up to ± 2^63)
       </li>
       <li>
        <code>
         boolean
        </code>
        (for true or false)
       </li>
       <li>
        <code>
         double
        </code>
        (for floating-point numbers, which represent a subset of the real numbers)
       </li>
       <li>
        <code>
         char
        </code>
        (for single characters like
        <code>
         'A'
        </code>
        and
        <code>
         '$'
        </code>
        )
       </li>
      </ul>
      <p>
       Java also has
       <strong>
        object types
       </strong>
       , for example:
      </p>
      <ul>
       <li>
        <code>
         String
        </code>
        represents a sequence of characters, like a Python string.
       </li>
       <li>
        <code>
         BigInteger
        </code>
        represents an integer of arbitrary size, so it acts like a Python integer.
       </li>
      </ul>
      <p>
       By Java convention, primitive types are lowercase, while object types start with a capital letter.
      </p>
      <p>
       <em>
        Operations
       </em>
       are functions that take inputs and produce outputs (and sometimes change the values themselves).  The syntax for operations varies, but we still think of them as functions no matter how they’re written.  Here are three different syntaxes for an operation in Python or Java:
      </p>
      <ul>
       <li>
        <em>
         As an infix, prefix, or postfix operator.
        </em>
        For example,
        <code>
         a + b
        </code>
        invokes the operation
        <code>
         + : int × int → int
        </code>
        .
       </li>
       <li>
        <em>
         As a method of an object.
        </em>
        For example,
        <code>
         bigint1.add(bigint2)
        </code>
        calls the operation
        <code>
         add: BigInteger × BigInteger → BigInteger
        </code>
        .
       </li>
       <li>
        <em>
         As a function.
        </em>
        For example,
        <code>
         Math.sin(theta)
        </code>
        calls the operation
        <code>
         sin: double → double
        </code>
        .  Here,
        <code>
         Math
        </code>
        is not an object.  It’s the class that contains the
        <code>
         sin
        </code>
        function.
       </li>
      </ul>
      <p>
       Contrast Java’s
       <code>
        str.length()
       </code>
       with Python’s
       <code>
        len(str)
       </code>
       .  It’s the same operation in both languages – a function that takes a string and returns its length – but it just uses different syntax.
      </p>
      <p>
       Some operations are
       <strong>
        overloaded
       </strong>
       in the sense that the same operation name is used for different types. The arithmetic operators
       <code>
        +
       </code>
       ,
       <code>
        -
       </code>
       ,
       <code>
        *
       </code>
       ,
       <code>
        /
       </code>
       are heavily overloaded for the numeric primitive types in Java.  Methods can also be overloaded. Most programming languages have some degree of overloading.
      </p>
     </div>
     <h2 id="static_typing">
      Static Typing
     </h2>
     <div data-outline="static_typing">
      <p>
       Java is a
       <strong>
        statically-typed language
       </strong>
       .  The types of all variables are known at compile time (before the program runs), and the compiler can therefore deduce the types of all expressions as well.  If
       <code>
        a
       </code>
       and
       <code>
        b
       </code>
       are declared as
       <code>
        int
       </code>
       s, then the compiler concludes that
       <code>
        a+b
       </code>
       is also an
       <code>
        int
       </code>
       .  The Eclipse environment does this while you’re writing the code, in fact, so you find out about many errors while you’re still typing.
      </p>
      <p>
       In
       <strong>
        dynamically-typed languages
       </strong>
       like Python, this kind of checking is deferred until runtime (while the program is running).
      </p>
      <p>
       Static typing is a particular kind of
       <strong>
        static checking
       </strong>
       , which means checking for bugs at compile time.  Bugs are the bane of programming.  Many of the ideas in this course are aimed at eliminating bugs from your code, and static checking is the first idea that we’ve seen for this.  Static typing prevents a large class of bugs from infecting your program: to be precise, bugs caused by applying an operation to the wrong types of arguments.  If you write a broken line of code like:
      </p>
      <pre><code class="hljs bash">   <span class="hljs-string">"5"</span> * <span class="hljs-string">"6"</span></code></pre>
      <p>
       that tries to multiply two strings, then static typing will catch this error while you’re still programming, rather than waiting until the line is reached during execution.
      </p>
     </div>
     <h2 id="static_checking_dynamic_checking_no_checking">
      Static Checking, Dynamic Checking, No Checking
     </h2>
     <div data-outline="static_checking_dynamic_checking_no_checking">
      <p>
       It’s useful to think about three kinds of automatic checking that a language can provide:
      </p>
      <ul>
       <li>
        <strong>
         Static checking
        </strong>
        : the bug is found automatically before the program even runs.
       </li>
       <li>
        <strong>
         Dynamic checking
        </strong>
        : the bug is found automatically when the code is executed.
       </li>
       <li>
        <strong>
         No checking
        </strong>
        : the language doesn’t help you find the error at all.  You have to watch for it yourself, or end up with wrong answers.
       </li>
      </ul>
      <p>
       Needless to say, catching a bug statically is better than catching it dynamically, and catching it dynamically is better than not catching it at all.
      </p>
      <p>
       Here are some rules of thumb for what errors you can expect to be caught at each of these times.
      </p>
      <p>
       <strong>
        Static checking
       </strong>
       can catch:
      </p>
      <ul>
       <li>
        syntax errors, like extra punctuation or spurious words.  Even dynamically-typed languages like Python do this kind of static checking.  If you have an indentation error in your Python program, you’ll find out before the program starts running.
       </li>
       <li>
        wrong names, like
        <code>
         Math.sine(2)
        </code>
        .  (The right name is
        <code>
         sin
        </code>
        .)
       </li>
       <li>
        wrong number of arguments, like
        <code>
         Math.sin(30, 20)
        </code>
        .
       </li>
       <li>
        wrong argument types, like
        <code>
         Math.sin("30")
        </code>
        .
       </li>
       <li>
        wrong return types, like
        <code>
         return "30";
        </code>
        from a function that’s declared to return an
        <code>
         int
        </code>
        .
       </li>
      </ul>
      <p>
       <strong>
        Dynamic checking
       </strong>
       can catch:
      </p>
      <ul>
       <li>
        illegal argument values.  For example, the integer expression
        <code>
         x/y
        </code>
        is only erroneous when
        <code>
         y
        </code>
        is actually zero; otherwise it works.  So in this expression, divide-by-zero is not a static error, but a dynamic error.
       </li>
       <li>
        unrepresentable return values, i.e., when the specific return value can’t be represented in the type.
       </li>
       <li>
        out-of-range indexes, e.g., using a negative or too-large index on a string.
       </li>
       <li>
        calling a method on a
        <code>
         null
        </code>
        object reference (
        <code>
         null
        </code>
        is like Python
        <code>
         None
        </code>
        ).
       </li>
      </ul>
      <p>
       Static checking tends to be about types, errors that are independent of the specific value that a variable has. A type is a set of values.  Static typing guarantees that a variable will have
       <em>
        some
       </em>
       value from that set, but we don’t know until runtime exactly which value it has.  So if the error would be caused only by certain values, like divide-by-zero or index-out-of-range then the compiler won’t raise a static error about it.
      </p>
      <p>
       Dynamic checking, by contrast, tends to be about errors caused by specific values.
      </p>
     </div>
     <h2 id="surprise_primitive_types_are_not_true_numbers">
      Surprise: Primitive Types Are Not True Numbers
     </h2>
     <div data-outline="surprise_primitive_types_are_not_true_numbers">
      <p>
       One trap in Java – and many other programming languages – is that its primitive numeric types have corner cases that do not behave like the integers and real numbers we’re used to.  As a result, some errors that really should be dynamically checked are not checked at all.  Here are the traps:
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Integer division
         </strong>
         .
         <code>
          5/2
         </code>
         does not return a fraction, it returns a truncated integer.  So this is an example of where what we might have hoped would be a dynamic error (because a fraction isn’t representable as an integer) frequently produces the wrong answer instead.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Integer overflow
         </strong>
         .  The
         <code>
          int
         </code>
         and
         <code>
          long
         </code>
         types are actually finite sets of integers, with maximum and minimum values.  What happens when you do a computation whose answer is too positive or too negative to fit in that finite range?  The computation quietly
         <em>
          overflows
         </em>
         (wraps around), and returns an integer from somewhere in the legal range but not the right answer.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Special values in
          <code>
           float
          </code>
          and
          <code>
           doubles
          </code>
         </strong>
         .  The
         <code>
          float
         </code>
         and
         <code>
          double
         </code>
         types have several special values that aren’t real numbers:
         <code>
          NaN
         </code>
         (which stands for “Not a Number”),
         <code>
          POSITIVE_INFINITY
         </code>
         , and
         <code>
          NEGATIVE_INFINITY
         </code>
         .  So operations that you’d expect to produce dynamic errors, like dividing by zero or taking the square root of a negative number, produce one of these special values instead.  If you keep computing with it, you’ll end up with a bad final answer.
        </p>
       </li>
      </ul>
     </div>
     <h2 id="arrays_and_collections">
      Arrays and Collections
     </h2>
     <div data-outline="arrays_and_collections">
      <p>
       Let’s change our hailstone computation so that it stores the sequence in a data structure, instead of just printing it out.  Java has two kinds of list-like types that we could use: arrays and Lists.
      </p>
      <p>
       Arrays are fixed-length sequences of another type T.  For example, here’s how to declare an array variable and construct an array value to assign to it:
      </p>
      <pre><code class="hljs cpp">  <span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];</code></pre>
      <p>
       The
       <code>
        int[]
       </code>
       array type includes all possible array values, but a particular array value, once created, can never change its length.  Operations on array types include:
      </p>
      <ul>
       <li>
        indexing:
        <code>
         a[2]
        </code>
       </li>
       <li>
        assignment:
        <code>
         a[2]=0
        </code>
       </li>
       <li>
        length:
        <code>
         a.length
        </code>
        (note that this is different syntax from
        <code>
         String.length()
        </code>
        –
        <code>
         a.length
        </code>
        is not a method call, so you don’t put parentheses after it)
       </li>
      </ul>
      <p>
       Here’s a crack at the hailstone code using an array.  We start by constructing the array, and then use an index variable
       <code>
        i
       </code>
       to step through the array, storing values of the sequence as we generate them.
      </p>
      <pre><code class="hljs cpp"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];  <span class="hljs-comment">// &lt;==== DANGER WILL ROBINSON</span>
<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;
<span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>;
<span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) {
    a[i] = n;
    i++;  <span class="hljs-comment">// very common shorthand for i=i+1</span>
    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        n = n / <span class="hljs-number">2</span>;
    } <span class="hljs-keyword">else</span> {
        n = <span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>;
    }
}
a[i] = n;
i++;</code></pre>
      <p>
       Something should immediately smell wrong in this approach.  What’s that magic number 100?  What would happen if we tried an n that turned out to have a very long hailstone sequence?  It wouldn’t fit in a length-100 array.  We have a bug. Would Java catch the bug statically, dynamically, or not at all? Incidentally, bugs like these – overflowing a fixed-length array, which are commonly used in less-safe languages like C and C++ that don’t do automatic runtime checking of array accesses – have been responsible for a large number of network security breaches and internet worms.
      </p>
      <p>
       Instead of a fixed-length array, let’s use the
       <code>
        List
       </code>
       type.  Lists are variable-length sequences of another type
       <code>
        T
       </code>
       .  Here’s how we can declare a
       <code>
        List
       </code>
       variable and make a list value:
      </p>
      <pre><code class="hljs php">  <span class="hljs-keyword">List</span>&lt;Integer&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</code></pre>
      <p>
       And here are some of its operations:
      </p>
      <ul>
       <li>
        indexing:
        <code>
         list.get(2)
        </code>
       </li>
       <li>
        assignment:
        <code>
         list.set(2, 0)
        </code>
       </li>
       <li>
        length:
        <code>
         list.size()
        </code>
       </li>
      </ul>
      <p>
       Note that
       <code>
        List
       </code>
       is an interface, a type that can’t be constructed directly with new, but that instead specifies the operations that a List must provide.  We’ll talk about this notion in a future class on abstract data types.
       <code>
        ArrayList
       </code>
       is a class, a concrete type that provides implementations of those operations.
       <code>
        ArrayList
       </code>
       isn’t the only implementation of the List type, though it’s the most commonly used one.
       <code>
        LinkedList
       </code>
       is another.  Check them out in the Java API documentation, which you can find by searching the web for “Java 8 API”.  Get to know the Java API docs, they’re your friend.  (“API” means “application programmer interface,” and is commonly used as a synonym for “library.”)
      </p>
      <p>
       Note also that we wrote
       <code>
        List&lt;Integer&gt;
       </code>
       instead of
       <code>
        List&lt;int&gt;
       </code>
       .  Unfortunately we can’t write
       <code>
        List&lt;int&gt;
       </code>
       in direct analog to
       <code>
        int[]
       </code>
       .  Lists only know how to deal with object types, not primitive types.  In Java, each of the primitive types (which are written in lowercase and often abbreviated, like
       <code>
        int
       </code>
       ) has an equivalent object type (which is capitalized, and fully spelled out, like
       <code>
        Integer
       </code>
       ).  Java requires us to use these object type equivalents when we parameterize a type with angle brackets. But in other contexts, Java automatically converts between
       <code>
        int
       </code>
       and
       <code>
        Integer
       </code>
       , so we can write
       <code>
        Integer i = 5
       </code>
       without any type error.
      </p>
      <p>
       Here’s the hailstone code written with Lists:
      </p>
      <pre><code class="language-java hljs">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
<span class="hljs-keyword">int</span> n = <span class="hljs-number">3</span>;
<span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) {
    list.add(n);
    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
        n = n / <span class="hljs-number">2</span>;
    } <span class="hljs-keyword">else</span> {
        n = <span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>;
    }
}
list.add(n);</code></pre>
      <p>
       Not only simpler but safer too, because the List automatically enlarges itself to fit as many numbers as you add to it (until you run out of memory, of course).
      </p>
     </div>
     <h2 id="iterating">
      Iterating
     </h2>
     <div data-outline="iterating">
      <p>
       A for loop steps through the elements of an array or a list, just as in Python, though the syntax looks a little different.  For example:
      </p>
      <pre><code class="hljs cpp"><span class="hljs-comment">// find the maximum point of a hailstone sequence stored in list</span>
<span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : <span class="hljs-built_in">list</span>) {
    max = Math.max(x, max);
}</code></pre>
      <p>
       You can iterate through arrays as well as lists.  The same code would work if the list were replaced by an array.
      </p>
      <p>
       <code>
        Math.max()
       </code>
       is a handy function from the Java API.  The
       <code>
        Math
       </code>
       class is full of useful functions like this – search for “java 8 Math” on the web to find its documentation.
      </p>
     </div>
     <h2 id="methods">
      Methods
     </h2>
     <div data-outline="methods">
      <p>
       In Java, statements generally have to be inside a method, and every method has to be in a class, so the simplest way to write our hailstone program looks like this:
      </p>
      <pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hailstone</span> </span>{
  <span class="hljs-comment handout-javadoc-comment">/**
   * Compute a hailstone sequence.
   * <span class="hljs-doctag">@param</span> n  Starting number for sequence.  Assumes n &gt; 0.
   * <span class="hljs-doctag">@return</span> hailstone sequence starting with n and ending with 1.
   */</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title">hailstoneSequence</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>{
    List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();
    <span class="hljs-keyword">while</span> (n != <span class="hljs-number">1</span>) {
        list.add(n);
        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) {
            n = n / <span class="hljs-number">2</span>;
        } <span class="hljs-keyword">else</span> {
            n = <span class="hljs-number">3</span> * n + <span class="hljs-number">1</span>;
        }
    }
    list.add(n);
    <span class="hljs-keyword">return</span> list;
  }
}</code></pre>
      <p>
       Let’s explain a few of the new things here.
      </p>
      <p>
       <code>
        public
       </code>
       means that any code, anywhere in your program, can refer to the class or method.  Other access modifiers, like private, are used to get more safety in a program, and to guarantee immutability for immutable types.  We’ll talk more about them in an upcoming class.
      </p>
      <p>
       <code>
        static
       </code>
       means that the method doesn’t take a self parameter – which in Java is implicit anyway, you won’t ever see it as a method parameter.   Static methods can’t be called on an object.  Contrast that with the
       <code>
        List
       </code>
       <code>
        add()
       </code>
       method or the
       <code>
        String
       </code>
       <code>
        length()
       </code>
       method, for example, which require an object to come first.  Instead, the right way to call a static method uses the class name instead of an object reference:
      </p>
      <pre><code class="language-java hljs">  Hailstone.hailstoneSequence(<span class="hljs-number">83</span>)</code></pre>
      <p>
       Take note also of the comment before the method, because it’s very important.  This comment is a specification of the method, describing the inputs and outputs of the operation. The specification should be concise and clear and precise. The comment provides information that is not already clear from the method types.  It doesn’t say, for example, that
       <code>
        n
       </code>
       is an integer, because the
       <code>
        int n
       </code>
       declaration just below already says that.  But it does say that
       <code>
        n
       </code>
       must be positive, which is not captured by the type declaration but is very important for the caller to know.
      </p>
      <p>
       We’ll have a lot more to say about how to write good specifications in a few classes, but you’ll have to start reading them and using them right away.
      </p>
     </div>
     <h2 id="mutating_values_vs_reassigning_variables">
      Mutating Values vs. Reassigning Variables
     </h2>
     <div data-outline="mutating_values_vs_reassigning_variables">
      <p>
       The next reading will introduce
       <em>
        snapshot diagrams
       </em>
       to give us a way to visualize the distinction between changing a variable and changing a value.  When you assign to a variable, you’re changing where the variable’s arrow points.  You can point it to a different value.
      </p>
      <p>
       When you assign to the contents of a mutable value – such as an array or list – you’re changing references inside that value.
      </p>
      <p>
       Change is a necessary evil.  Good programmers avoid things that change, because they may change unexpectedly.
      </p>
      <p>
       Immutability (immunity from change) is a major design principle in this course. Immutable types are types whose values can never change once they have been created.  (At least not in a way that’s visible to the outside world – there are some subtleties there that we’ll talk more about in a future class about immutability.)  Which of the types we’ve discussed so far are immutable, and which are mutable?
      </p>
      <p>
       Java also gives us immutable references: variables that are assigned once and never reassigned.  To make a reference immutable, declare it with the keyword final:
      </p>
      <pre><code class="hljs java">  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> n = <span class="hljs-number">5</span>;</code></pre>
      <p>
       If the Java compiler isn’t convinced that your final variable will only be assigned once at runtime, then it will produce a compiler error.  So final gives you static checking for immutable references.
      </p>
      <p>
       It’s good practice to use final for declaring the parameters of a method and as many local variables as possible.  Like the type of the variable, these declarations are important documentation, useful to the reader of the code and statically checked by the compiler.
      </p>
      <p>
       There are two variables in our hailstoneSequence method: can we declare them final, or not?
      </p>
      <pre><code class="hljs php">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">List</span>&lt;Integer&gt; hailstoneSequence(<span class="hljs-keyword">final</span> int n) { 
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">List</span>&lt;Integer&gt; <span class="hljs-keyword">list</span> = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();</code></pre>
     </div>
     <h2 id="documenting_assumptions">
      Documenting Assumptions
     </h2>
     <div data-outline="documenting_assumptions">
      <p>
       Writing the type of a variable down documents an assumption about it: e.g., this variable will always refer to an integer.  Java actually checks this assumption at compile time, and guarantees that there’s no place in your program where you violated this assumption.
      </p>
      <p>
       Declaring a variable final is also a form of documentation, a claim that the variable will never change after its initial assignment.  Java checks that too, statically.
      </p>
      <p>
       We documented another assumption that Java (unfortunately) doesn’t check automatically: that n must be positive.
      </p>
      <p>
       Why do we need to write down our assumptions?  Because programming is full of them, and if we don’t write them down, we won’t remember them, and other people who need to read or change our programs later won’t know them.  They’ll have to guess.
      </p>
      <p>
       Programs have to be written with two goals in mind:
      </p>
      <ul>
       <li>
        communicating with the computer.  First persuading the compiler that your program is sensible – syntactically correct and type-correct.  Then getting the logic right so that it gives the right results at runtime.
       </li>
       <li>
        communicating with other people.  Making the program easy to understand, so that when somebody has to fix it, improve it, or adapt it in the future, they can do so.
       </li>
      </ul>
     </div>
     <h2 id="hacking_vs_engineering">
      Hacking vs. Engineering
     </h2>
     <div data-outline="hacking_vs_engineering">
      <p>
       We’ve written some hacky code in this class.  Hacking is often marked by unbridled optimism:
      </p>
      <ul>
       <li>
        Bad: writing lots of code before testing any of it
       </li>
       <li>
        Bad: keeping all the details in your head, assuming you’ll remember them forever, instead of writing them down in your code
       </li>
       <li>
        Bad: assuming that bugs will be nonexistent or else easy to find and fix
       </li>
      </ul>
      <p>
       But software engineering is not hacking.  Engineers are pessimists:
      </p>
      <ul>
       <li>
        Good: write a little bit at a time, testing as you go.  In a future class, we’ll talk about test-first programming.
       </li>
       <li>
        Good: document the assumptions that your code depends on
       </li>
       <li>
        Good: defend your code against stupidity – especially your own!  Static checking helps with that.
       </li>
      </ul>
     </div>
     <h2 id="the_goal_of_6005">
      The Goal of 6.005
     </h2>
     <div data-outline="the_goal_of_6005">
      <p>
       Our primary goal in this course is learning how to produce software that is:
      </p>
      <ul>
       <li>
        <strong>
         Safe from bugs
        </strong>
        .  Correctness (correct behavior right now), and defensiveness (correct behavior in the future).
       </li>
       <li>
        <strong>
         Easy to understand
        </strong>
        .  Has to communicate to future programmers who need to understand it and make changes in it (fixing bugs or adding new features).  That future programmer might be you, months or years from now.  You’ll be surprised how much you forget if you don’t write it down, and how much it helps your own future self to have a good design.
       </li>
       <li>
        <strong>
         Ready for change
        </strong>
        .  Software always changes.  Some designs make it easy to make changes; others require throwing away and rewriting a lot of code.
       </li>
      </ul>
      <p>
       There are other important properties of software (like performance, usability, security), and they may trade off against these three.  But these are the Big Three that we care about in 6.005, and that software developers generally put foremost in the practice of building software.  It’s worth considering every language feature, every programming practice, every design pattern that we study in this course, and understanding how they relate to the Big Three.
      </p>
     </div>
     <h2 id="why_we_use_java_in_this_course">
      Why we use Java in this course
     </h2>
     <div data-outline="why_we_use_java_in_this_course">
      <p>
       Since you’ve had 6.01, we’re assuming that you’re comfortable with Python.  So why aren’t we using Python in this course?  Why do we use Java in 6.005?
      </p>
      <p>
       <strong>
        Safety
       </strong>
       is the first reason.  Java has static checking (primarily type checking, but other kinds of static checks too, like that your code returns values from methods declared to do so).  We’re studying software engineering in this course, and safety from bugs is a key tenet of that approach.  Java dials safety up to 11, which makes it a good language for learning about good software engineering practices. It’s certainly possible to write safe code in dynamic languages like Python, but it’s easier to understand what you need to do if you learn how in a safe, statically-checked language.
      </p>
      <p>
       <strong>
        Ubiquity
       </strong>
       is another reason.  Java is widely used in research, education, and industry.  Java runs on many platforms, not just Windows/Mac/Linux.  Java can be used for web programming (both on the server and in the client), and native Android programming is done in Java.  Although other programming languages are far better suited to teaching programming (Scheme and ML come to mind), regrettably these languages aren’t as widespread in the real world. Java on your resume will be recognized as a marketable skill.  But don’t get us wrong: the real skills you’ll get from this course are not Java-specific, but carry over to any language that you might program in.  The most important lessons from this course will survive language fads: safety, clarity, abstraction, engineering instincts.
      </p>
      <p>
       In any case, a good programmer must be
       <strong>
        multilingual
       </strong>
       .  Programming languages are tools, and you have to use the right tool for the job.  You will certainly have to pick up other programming languages before you even finish your MIT career (JavaScript, C/C++, Scheme or Ruby or ML or Haskell), so we’re getting started now by learning a second one.
      </p>
      <p>
       As a result of its ubiquity, Java has a wide array of interesting and useful
       <strong>
        libraries
       </strong>
       (both its enormous built-in library, and other libraries out on the net), and excellent free
       <strong>
        tools
       </strong>
       for development (IDEs like Eclipse, editors, compilers, test frameworks, profilers, code coverage, style checkers).  Even Python is still behind Java in the richness of its ecosystem.
      </p>
      <p>
       There are some reasons to regret using Java.  It’s wordy, which makes it hard to write examples on the board.  It’s large, having accumulated many features over the years.  It’s internally inconsistent (e.g. the
       <code>
        final
       </code>
       keyword means different things in different contexts, and the
       <code>
        static
       </code>
       keyword in Java has nothing to do with static checking).  It’s weighted with the baggage of older languages like C/C++ (the primitive types and the
       <code>
        switch
       </code>
       statement are good examples). It has no interpreter like Python’s, where you can learn by playing with small bits of code.
      </p>
      <p>
       But on the whole, Java is a reasonable choice of language right now to learn how to write code that is safe from bugs, easy to understand, and ready for change.  And that’s our goal.
      </p>
     </div>
     <h2 id="summary">
      Summary
     </h2>
     <div data-outline="summary">
      <p>
       The main idea we introduced today is
       <strong>
        static checking
       </strong>
       .  Here’s how this idea relates to the goals of the course:
      </p>
      <ul>
       <li>
        <p>
         <strong>
          Safe from bugs.
         </strong>
         Static checking helps with safety by catching type errors and other bugs before runtime.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Easy to understand.
         </strong>
         It helps with understanding, because types are explicitly stated in the code.
        </p>
       </li>
       <li>
        <p>
         <strong>
          Ready for change.
         </strong>
         Static checking makes it easier to change your code by identifying other places that need to change in tandem.  For example, when you change the name or type of a variable, the compiler immediately displays errors at all the places where that variable is used, reminding you to update them as well.
        </p>
       </li>
      </ul>
     </div>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/01-static-checking/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:11 GMT -->
</html>
<!-- Handout delivered Tue Feb 16 2016 15:22:40 GMT-0500 (EST) -->
