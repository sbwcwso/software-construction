<!DOCTYPE html>
<html>
 
<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/12-abstract-data-types/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:52 GMT -->
<head>
  <meta charset="utf-8">
   <title>
    Reading 12: Abstract Data Types
   </title>
   <link href="../../web/handout-style.css" rel="stylesheet">
    <style>
     .adts-in-java-table th, .adts-in-java-table td {
  vertical-align: top;
  padding: 0 10px 0;
}
.adts-in-java-table p {
  margin: 0px;
}
.adts-in-java-table .new-row td {
  padding-top: 10px;
}
.adts-in-java-table .new-row td:first-child {
  white-space: nowrap;
}
    </style>
    <meta content="width=device-width, initial-scale=1" name="viewport"/>
   </link>
  </meta>
 </head>
 <body>
  <header>
   <a href="../../index.html">
    6.005 — Software Construction on MIT OpenCourseWare
   </a>
   |
   <a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">
    OCW 6.005 Homepage
   </a>
   <div>
    Spring 2016
   </div>
  </header>
  <nav class="table-of-contents col-sm-2">
   <ul class="nav">
    <li>
     <a href="#reading_12_abstract_data_types">
      Reading 12: Abstract Data Types
     </a>
    </li>
    <li>
     <a href="#what_abstraction_means">
      What Abstraction Means
     </a>
    </li>
    <li>
     <a href="#classifying_types_and_operations">
      Classifying Types and Operations
     </a>
    </li>
    <li>
     <a href="#designing_an_abstract_type">
      Designing an Abstract Type
     </a>
    </li>
    <li>
     <a href="#representation_independence">
      Representation Independence
     </a>
    </li>
    <li>
     <a href="#realizing_adt_concepts_in_java">
      Realizing ADT Concepts in Java
     </a>
    </li>
    <li>
     <a href="#testing_an_abstract_data_type">
      Testing an Abstract Data Type
     </a>
    </li>
    <li>
     <a href="#summary">
      Summary
     </a>
    </li>
   </ul>
  </nav>
  <main class="container-fluid">
   <h1 class="handout-title col-sm-8 col-sm-offset-2" id="reading_12_abstract_data_types">
    Reading 12: Abstract Data Types
   </h1>
   <div data-outline="reading_12_abstract_data_types">
    <div class="markdown col-sm-8 col-sm-offset-2 converted">
     <h4>
      Software in 6.005
     </h4>
     <table class="table table-striped no-markdown">
      <tbody>
       <tr>
        <th width="33%">
         Safe from bugs
        </th>
        <th>
         Easy to understand
        </th>
        <th>
         Ready for change
        </th>
       </tr>
       <tr>
        <td>
         Correct today and correct in the unknown future.
        </td>
        <td>
         Communicating clearly with future programmers, including future you.
        </td>
        <td>
         Designed to accommodate change without rewriting.
        </td>
       </tr>
      </tbody>
     </table>
     <h4>
      Objectives
     </h4>
     <p>
      Today’s class introduces two ideas:
     </p>
     <ul>
      <li>
       Abstract data types
      </li>
      <li>
       Representation independence
      </li>
     </ul>
     <p>
      In this reading, we look at a powerful idea, abstract data types, which enable us to separate how we use a data structure in a program from the particular form of the data structure itself.
     </p>
     <p>
      Abstract data types address a particularly dangerous problem: clients making assumptions about the type’s internal representation. We’ll see why this is dangerous and how it can be avoided. We’ll also discuss the classification of operations, and some principles of good design for abstract data types.
     </p>
     <h3 id="access_control_in_java">
      Access Control in Java
     </h3>
     <div data-outline="access_control_in_java">
      <div class="handout-solo alert alert-warning">
       <p>
        You should already have read:
        <strong>
         <a class="alert-link" href="http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html">
          Controlling Access to Members of a Class
         </a>
        </strong>
        in the Java Tutorials.
       </p>
      </div>
      <h2 id="what_abstraction_means">
       What Abstraction Means
      </h2>
      <div data-outline="what_abstraction_means">
       <p>
        Abstract data types are an instance of a general principle in software engineering, which goes by many names with slightly different shades of meaning.  Here are some of the names that are used for this idea:
       </p>
       <ul>
        <li>
         <strong>
          Abstraction.
         </strong>
         Omitting or hiding low-level details with a simpler, higher-level idea.
        </li>
        <li>
         <strong>
          Modularity.
         </strong>
         Dividing a system into components or modules, each of which can be designed, implemented, tested, reasoned about, and reused separately from the rest of the system.
        </li>
        <li>
         <strong>
          Encapsulation.
         </strong>
         Building walls around a module (a hard shell or capsule) so that the module is responsible for its own internal behavior, and bugs in other parts of the system can’t damage its integrity.
        </li>
        <li>
         <strong>
          Information hiding.
         </strong>
         Hiding details of a module’s implementation from the rest of the system, so that those details can be changed later without changing the rest of the system.
        </li>
        <li>
         <strong>
          Separation of concerns.
         </strong>
         Making a feature (or “concern”) the responsibility of a single module, rather than spreading it across multiple modules.
        </li>
       </ul>
       <p>
        As a software engineer, you should know these terms, because you will run into them frequently.
The fundamental purpose of all of these ideas is to help achieve the three important properties that we care about in 6.005: safety from bugs, ease of understanding, and readiness for change.
       </p>
       <h3 id="user-defined_types">
        User-Defined Types
       </h3>
       <div data-outline="user-defined_types">
        <p>
         In the early days of computing, a programming language came with built-in types (such as integers, booleans, strings, etc.) and built-in procedures, e.g., for input and output.
Users could define their own procedures: that’s how large programs were built.
        </p>
        <p>
         A major advance in software development was the idea of abstract types: that one could design a programming language to allow user-defined types, too.
This idea came out of the work of many researchers, notably Dahl (the inventor of the Simula language), Hoare (who developed many of the techniques we now use to reason about abstract types), Parnas (who coined the term information hiding and first articulated the idea of organizing program modules around the secrets they encapsulated), and here at MIT, Barbara Liskov and John Guttag, who did seminal work in the specification of abstract types, and in programming language support for them – and developed the original 6.170, the predecessor to 6.005.
Barbara Liskov earned the Turing Award, computer science’s equivalent of the Nobel Prize, for her work on abstract types.
        </p>
        <p>
         The key idea of data abstraction is that a type is characterized by the operations you can perform on it.
A number is something you can add and multiply; a string is something you can concatenate and take substrings of; a boolean is something you can negate, and so on.
In a sense, users could already define their own types in early programming languages: you could create a record type date, for example, with integer fields for day, month, and year.
But what made abstract types new and different was the focus on operations: the user of the type would not need to worry about how its values were actually stored, in the same way that a programmer can ignore how the compiler actually stores integers.
All that matters is the operations.
        </p>
        <p>
         In Java, as in many modern programming languages, the separation between built-in types and user-defined types is a bit blurry.
The classes in java.lang, such as Integer and Boolean are built-in; whether you regard all the collections of java.util as built-in is less clear (and not very important anyway).
Java complicates the issue by having primitive types that are not objects.
The set of these types, such as int and boolean, cannot be extended by the user.
        </p>
       </div>
      </div>
      <h2 id="classifying_types_and_operations">
       Classifying Types and Operations
      </h2>
      <div data-outline="classifying_types_and_operations">
       <p>
        Types, whether built-in or user-defined, can be classified as
        <strong>
         mutable
        </strong>
        or
        <strong>
         immutable
        </strong>
        .
The objects of a mutable type can be changed: that is, they provide operations which when executed cause the results of other operations on the same object to give different results.
So
        <code>
         Date
        </code>
        is mutable, because you can call
        <code>
         setMonth
        </code>
        and observe the change with the
        <code>
         getMonth
        </code>
        operation.
But
        <code>
         String
        </code>
        is immutable, because its operations create new
        <code>
         String
        </code>
        objects rather than changing existing ones.
Sometimes a type will be provided in two forms, a mutable and an immutable form.
        <code>
         StringBuilder
        </code>
        , for example, is a mutable version of
        <code>
         String
        </code>
        (although the two are certainly not the same Java type, and are not interchangeable).
       </p>
       <p>
        The operations of an abstract type are classified as follows:
       </p>
       <ul>
        <li>
         <strong>
          Creators
         </strong>
         create new objects of the type.
A creator may take an object as an argument, but not an object of the type being constructed.
        </li>
        <li>
         <strong>
          Producers
         </strong>
         create new objects from old objects of the type.
The
         <code>
          concat
         </code>
         method of
         <code>
          String
         </code>
         , for example, is a producer: it takes two strings and produces a new one representing their concatenation.
        </li>
        <li>
         <strong>
          Observers
         </strong>
         take objects of the abstract type and return objects of a different type.
The
         <code>
          size
         </code>
         method of
         <code>
          List
         </code>
         , for example, returns an
         <code>
          int
         </code>
         .
        </li>
        <li>
         <strong>
          Mutators
         </strong>
         change objects.
The
         <code>
          add
         </code>
         method of
         <code>
          List
         </code>
         , for example, mutates a list by adding an element to the end.
        </li>
       </ul>
       <p>
        We can summarize these distinctions schematically like this (explanation to follow):
       </p>
       <ul>
        <li>
         creator : t* → T
        </li>
        <li>
         producer : T+, t* → T
        </li>
        <li>
         observer : T+, t* → t
        </li>
        <li>
         mutator : T+, t* → void | t | T
        </li>
       </ul>
       <p>
        These show informally the shape of the signatures of operations in the various classes.
Each
        <em>
         T
        </em>
        is the abstract type itself; each
        <em>
         t
        </em>
        is some other type.
The
        <code>
         +
        </code>
        marker indicates that the type may occur one or more times in that part of the signature, and the
        <code>
         *
        </code>
        marker indicates that it occurs zero or more times.
        <code>
         |
        </code>
        indicates or.
For example, a producer may take two values of the abstract type
        <em>
         T
        </em>
        , like
        <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#concat-java.lang.String-">
         <code>
          String.concat()
         </code>
        </a>
        does:
       </p>
       <ul>
        <li>
         concat : String × String → String
        </li>
       </ul>
       <p>
        Some observers take zero arguments of other types
        <em>
         t
        </em>
        , such as:
       </p>
       <ul>
        <li>
         <a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html#size--">
          size
         </a>
         : List → int
        </li>
       </ul>
       <p>
        … and others take several:
       </p>
       <ul>
        <li>
         <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#regionMatches-boolean-int-java.lang.String-int-int-">
          regionMatches
         </a>
         : String × boolean × int × String × int × int → boolean
        </li>
       </ul>
       <p>
        A creator operation is often implemented as a
        <em>
         constructor
        </em>
        , like
        <a href="https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--">
         <code>
          new ArrayList()
         </code>
        </a>
        .
But a creator can simply be a static method instead, like
        <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-">
         <code>
          Arrays.asList()
         </code>
        </a>
        .
A creator implemented as a static method is often called a
        <strong>
         factory method
        </strong>
        .
The various
        <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#valueOf-boolean-">
         <code>
          String.valueOf
         </code>
        </a>
        methods in Java are other examples of creators implemented as factory methods.
       </p>
       <p>
        Mutators are often signaled by a
        <code>
         void
        </code>
        return type.  A method that returns void
        <em>
         must
        </em>
        be called for some kind of side-effect, since otherwise it doesn’t return anything.  But not all mutators return void.  For example,
        <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Set.html#add-E-">
         <code>
          Set.add()
         </code>
        </a>
        returns a boolean that indicates whether the set was actually changed.  In Java’s graphical user interface toolkit,
        <a href="http://docs.oracle.com/javase/8/docs/api/java/awt/Container.html#add-java.awt.Component-">
         <code>
          Component.add()
         </code>
        </a>
        returns the object itself, so that multiple
        <code>
         add()
        </code>
        calls can be
        <a href="http://en.wikipedia.org/wiki/Method_chaining">
         chained together
        </a>
        .
       </p>
       <h3 id="abstract_data_type_examples">
        Abstract Data Type Examples
       </h3>
       <div data-outline="abstract_data_type_examples">
        <p>
         Here are some examples of abstract data types, along with some of their operations, grouped by kind.
        </p>
        <p>
         <strong>
          <code>
           int
          </code>
         </strong>
         is Java’s primitive integer type.
         <code>
          int
         </code>
         is immutable, so it has no mutators.
        </p>
        <ul>
         <li>
          creators: the numeric literals
          <code>
           0
          </code>
          ,
          <code>
           1
          </code>
          ,
          <code>
           2
          </code>
          , …
         </li>
         <li>
          producers: arithmetic operators
          <code>
           +
          </code>
          ,
          <code>
           -
          </code>
          ,
          <code>
           *
          </code>
          ,
          <code>
           /
          </code>
         </li>
         <li>
          observers: comparison operators
          <code>
           ==
          </code>
          ,
          <code>
           !=
          </code>
          ,
          <code>
           &lt;
          </code>
          ,
          <code>
           &gt;
          </code>
         </li>
         <li>
          mutators: none (it’s immutable)
         </li>
        </ul>
        <p>
         <strong>
          <code>
           List
          </code>
         </strong>
         is Java’s list type.
         <code>
          List
         </code>
         is mutable.
         <code>
          List
         </code>
         is also an interface, which means that other classes provide the actual implementation of the data type.
These classes include
         <code>
          ArrayList
         </code>
         and
         <code>
          LinkedList
         </code>
         .
        </p>
        <ul>
         <li>
          creators:
          <code>
           ArrayList
          </code>
          and
          <code>
           LinkedList
          </code>
          constructors,
          <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-">
           <code>
            Collections.singletonList
           </code>
          </a>
         </li>
         <li>
          producers:
          <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-T-">
           <code>
            Collections.unmodifiableList
           </code>
          </a>
         </li>
         <li>
          observers:
          <code>
           size
          </code>
          ,
          <code>
           get
          </code>
         </li>
         <li>
          mutators:
          <code>
           add
          </code>
          ,
          <code>
           remove
          </code>
          ,
          <code>
           addAll
          </code>
          ,
          <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#sort-java.util.List-">
           <code>
            Collections.sort
           </code>
          </a>
         </li>
        </ul>
        <p>
         <strong>
          <code>
           String
          </code>
         </strong>
         is Java’s string type.
         <code>
          String
         </code>
         is immutable.
        </p>
        <ul>
         <li>
          creators:
          <code>
           String
          </code>
          constructors
         </li>
         <li>
          producers:
          <code>
           concat
          </code>
          ,
          <code>
           substring
          </code>
          ,
          <code>
           toUpperCase
          </code>
         </li>
         <li>
          observers:
          <code>
           length
          </code>
          ,
          <code>
           charAt
          </code>
         </li>
         <li>
          mutators: none (it’s immutable)
         </li>
        </ul>
        <p>
         This classification gives some useful terminology, but it’s not perfect.
In complicated data types, there may be an operation that is both a producer and a mutator, for example.
Some people reserve the term
         <em>
          producer
         </em>
         only for operations that do no mutation.
        </p>
       </div>
      </div>
      <h2 id="designing_an_abstract_type">
       Designing an Abstract Type
      </h2>
      <div data-outline="designing_an_abstract_type">
       <p>
        Designing an abstract type involves choosing good operations and determining how they should behave.
Here are a few rules of thumb.
       </p>
       <p>
        It’s better to have
        <strong>
         a few, simple operations
        </strong>
        that can be combined in powerful ways, rather than lots of complex operations.
       </p>
       <p>
        Each operation should have a well-defined purpose, and should have a
        <strong>
         coherent
        </strong>
        behavior rather than a panoply of special cases.
We probably shouldn’t add a
        <code>
         sum
        </code>
        operation to
        <code>
         List
        </code>
        , for example.
It might help clients who work with lists of integers, but what about lists of strings? Or nested lists? All these special cases would make
        <code>
         sum
        </code>
        a hard operation to understand and use.
       </p>
       <p>
        The set of operations should be
        <strong>
         adequate
        </strong>
        in the sense that there must be enough to do the kinds of computations clients are likely to want to do.
A good test is to check that every property of an object of the type can be extracted.
For example, if there were no get operation, we would not be able to find out what the elements of a list are.
Basic information should not be inordinately difficult to obtain.
For example, the size method is not strictly necessary for List, because we could apply get on increasing indices until we get a failure, but this is inefficient and inconvenient.
       </p>
       <p>
        The type may be generic: a list or a set, or a graph, for example.
Or it may be domain-specific: a street map, an employee database, a phone book, etc.
But
        <strong>
         it should not mix generic and domain-specific features.
        </strong>
        A
        <code>
         Deck
        </code>
        type intended to represent a sequence of playing cards shouldn’t have a generic
        <code>
         add
        </code>
        method that accepts arbitrary objects like integers or strings.
Conversely, it wouldn’t make sense to put a domain-specific method like
        <code>
         dealCards
        </code>
        into the generic type
        <code>
         List
        </code>
        .
       </p>
      </div>
      <h2 id="representation_independence">
       Representation Independence
      </h2>
      <div data-outline="representation_independence">
       <p>
        Critically, a good abstract data type should be
        <strong>
         representation independent
        </strong>
        .
This means that the use of an abstract type is independent of its representation (the actual data structure or data fields used to implement it), so that changes in representation have no effect on code outside the abstract type itself.
For example, the operations offered by List are independent of whether the list is represented as a linked list or as an array.
       </p>
       <p>
        You won’t be able to change the representation of an ADT at all unless its operations are fully specified with preconditions and postconditions, so that clients know what to depend on, and you know what you can safely change.
       </p>
       <h3 id="example_different_representations_for_strings">
        Example: Different Representations for Strings
       </h3>
       <div data-outline="example_different_representations_for_strings">
        <p>
         Let’s look at a simple abstract data type to see what representation independence means and why it’s useful.
The
         <code>
          MyString
         </code>
         type below has far fewer operations than the real Java
         <code>
          String
         </code>
         , and their specs are a little different, but it’s still illustrative.  Here are the specs for the ADT:
        </p>
        <pre><code class="language-java hljs"><span class="hljs-comment handout-javadoc-comment">/** MyString represents an immutable sequence of characters. */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyString</span> </span>{ 

    <span class="hljs-comment">//////////////////// Example of a creator operation ///////////////</span>
    <span class="hljs-comment handout-javadoc-comment">/** <span class="hljs-doctag">@param</span> b a boolean value
     *  <span class="hljs-doctag">@return</span> string representation of b, either "true" or "false" */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyString <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>{ ... }

    <span class="hljs-comment">//////////////////// Examples of observer operations ///////////////</span>
    <span class="hljs-comment handout-javadoc-comment">/** <span class="hljs-doctag">@return</span> number of characters in this string */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>{ ... }

    <span class="hljs-comment handout-javadoc-comment">/** <span class="hljs-doctag">@param</span> i character position (requires 0 &lt;= i &lt; string length)
     *  <span class="hljs-doctag">@return</span> character at position i */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{ ... }

    <span class="hljs-comment">//////////////////// Example of a producer operation ///////////////    </span>
    <span class="hljs-comment handout-javadoc-comment">/** Get the substring between start (inclusive) and end (exclusive).
     *  <span class="hljs-doctag">@param</span> start starting index
     *  <span class="hljs-doctag">@param</span> end ending index.  Requires 0 &lt;= start &lt;= end &lt;= string length.
     *  <span class="hljs-doctag">@return</span> string consisting of charAt(start)...charAt(end-1) */</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> MyString <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{ ... }
}</code></pre>
        <p>
         These public operations and their specifications are the only information that a client of this data type is allowed to know.
Following the test-first programming paradigm, in fact, the first client we should create is a test suite that exercises these operations according to their specs.
At the moment, however, writing test cases that use
         <code>
          assertEquals
         </code>
         directly on
         <code>
          MyString
         </code>
         objects wouldn’t work, because we don’t have an equality operation defined on
         <code>
          MyString
         </code>
         .
We’ll talk about how to implement equality carefully in a later reading.
For now, the only operations we can perform with MyStrings are the ones we’ve defined above:
         <code>
          valueOf
         </code>
         ,
         <code>
          length
         </code>
         ,
         <code>
          charAt
         </code>
         , and
         <code>
          substring
         </code>
         .
Our tests have to limit themselves to those operations. For example, here’s one test for the
         <code>
          valueOf
         </code>
         operation:
        </p>
        <pre><code class="language-java hljs">MyString s = MyString.valueOf(<span class="hljs-keyword">true</span>);
assertEquals(<span class="hljs-number">4</span>, s.length());
assertEquals(<span class="hljs-string">'t'</span>, s.charAt(<span class="hljs-number">0</span>));
assertEquals(<span class="hljs-string">'r'</span>, s.charAt(<span class="hljs-number">1</span>));
assertEquals(<span class="hljs-string">'u'</span>, s.charAt(<span class="hljs-number">2</span>));
assertEquals(<span class="hljs-string">'e'</span>, s.charAt(<span class="hljs-number">3</span>));</code></pre>
        <p>
         We’ll come back to the question of testing ADTs at the end of this reading.
        </p>
        <p>
         For now, let’s look at a simple representation for
         <code>
          MyString
         </code>
         : just an array of characters, exactly the length of the string, with no extra room at the end.
Here’s how that internal representation would be declared, as an instance variable within the class:
        </p>
        <pre><code class="language-java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] a;</code></pre>
        <p>
         With that choice of representation, the operations would be implemented in a straightforward way:
        </p>
        <pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyString <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>{
    MyString s = <span class="hljs-keyword">new</span> MyString();
    s.a = b ? <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] { <span class="hljs-string">'t'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'u'</span>, <span class="hljs-string">'e'</span> } 
            : <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] { <span class="hljs-string">'f'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'s'</span>, <span class="hljs-string">'e'</span> };
    <span class="hljs-keyword">return</span> s;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> a.length;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
    <span class="hljs-keyword">return</span> a[i];
}

<span class="hljs-function"><span class="hljs-keyword">public</span> MyString <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
    MyString that = <span class="hljs-keyword">new</span> MyString();
    that.a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[end - start];
    System.arraycopy(<span class="hljs-keyword">this</span>.a, start, that.a, <span class="hljs-number">0</span>, end - start);
    <span class="hljs-keyword">return</span> that;
}</code></pre>
        <p>
         Question to ponder: Why don’t
         <code>
          charAt
         </code>
         and
         <code>
          substring
         </code>
         have to check whether their parameters are within the valid range?  What do you think will happen if the client calls these implementations with illegal inputs?
        </p>
        <p>
         One problem with this implementation is that it’s passing up an opportunity for performance improvement.
Because this data type is immutable, the
         <code>
          substring
         </code>
         operation doesn’t really have to copy characters out into a fresh array.
It could just point to the original
         <code>
          MyString
         </code>
         object’s character array and keep track of the start and end that the new substring object represents.
The String implementation in some versions of Java do this.
        </p>
        <p>
         To implement this optimization, we could change the internal representation of this class to:
        </p>
        <pre><code class="language-java hljs"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] a;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> start;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> end;</code></pre>
        <p>
         With this new representation, the operations are now implemented like this:
        </p>
        <pre><code class="language-java hljs"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MyString <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> b)</span> </span>{
    MyString s = <span class="hljs-keyword">new</span> MyString();
    s.a = b ? <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] { <span class="hljs-string">'t'</span>, <span class="hljs-string">'r'</span>, <span class="hljs-string">'u'</span>, <span class="hljs-string">'e'</span> } 
            : <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[] { <span class="hljs-string">'f'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'l'</span>, <span class="hljs-string">'s'</span>, <span class="hljs-string">'e'</span> };
    s.start = <span class="hljs-number">0</span>;
    s.end = s.a.length;
    <span class="hljs-keyword">return</span> s;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> end - start;
}

<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>{
  <span class="hljs-keyword">return</span> a[start + i];
}

<span class="hljs-function"><span class="hljs-keyword">public</span> MyString <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span> </span>{
    MyString that = <span class="hljs-keyword">new</span> MyString();
    that.a = <span class="hljs-keyword">this</span>.a;
    that.start = <span class="hljs-keyword">this</span>.start + start;
    that.end = <span class="hljs-keyword">this</span>.start + end;
    <span class="hljs-keyword">return</span> that;
}</code></pre>
        <p>
         Because
         <code>
          MyString
         </code>
         ’s existing clients depend only on the specs of its public methods, not on its private fields, we can make this change without having to inspect and change all that client code.  That’s the power of representation independence.
        </p>
       </div>
      </div>
      <h2 id="realizing_adt_concepts_in_java">
       Realizing ADT Concepts in Java
      </h2>
      <div data-outline="realizing_adt_concepts_in_java">
       <p>
        Let’s summarize some of the general ideas we’ve discussed in this reading, which are applicable in general to programming in any language, and their specific realization using Java language features.  The point is that there are several ways to do it, and it’s important to both understand the big idea, like a creator operation, and different ways to achieve that idea in practice.
       </p>
       <p>
        The only item in this table that hasn’t yet been discussed in this reading is the use of a constant object as a creator operation.  This pattern is commonly seen in immutable types, where the simplest or emptiest value of the type is simply a public constant, and producers are used to build up more complex values from it.
       </p>
       <table class="adts-in-java-table pull-margin">
        <tbody>
         <tr>
          <th>
           <p>
            ADT concept
           </p>
          </th>
          <th>
           <p>
            Ways to do it in Java
           </p>
          </th>
          <th>
           <p>
            Examples
           </p>
          </th>
         </tr>
         <tr class="new-row">
          <td rowspan="3">
           <p>
            Creator operation
           </p>
          </td>
          <td>
           <p>
            Constructor
           </p>
          </td>
          <td>
           <p>
            <a href="http://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html#ArrayList--">
             <code>
              ArrayList()
             </code>
            </a>
           </p>
          </td>
         </tr>
         <tr>
          <td>
           <p>
            Static (factory) method
           </p>
          </td>
          <td>
           <p>
            <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#singletonList-T-">
             <code>
              Collections.singletonList()
             </code>
            </a>
            ,
            <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList-T...-">
             <code>
              Arrays.asList()
             </code>
            </a>
           </p>
          </td>
         </tr>
         <tr>
          <td>
           <p>
            Constant
           </p>
          </td>
          <td>
           <p>
            <a href="http://docs.oracle.com/javase/8/docs/api/java/math/BigInteger.html#ZERO">
             <code>
              BigInteger.ZERO
             </code>
            </a>
           </p>
          </td>
         </tr>
         <tr class="new-row">
          <td rowspan="2">
           <p>
            Observer operation
           </p>
          </td>
          <td>
           <p>
            Instance method
           </p>
          </td>
          <td>
           <p>
            <a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html#get-int-">
             <code>
              List.get()
             </code>
            </a>
           </p>
          </td>
         </tr>
         <tr>
          <td>
           <p>
            Static method
           </p>
          </td>
          <td>
           <p>
            <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#max-java.util.Collection-">
             <code>
              Collections.max()
             </code>
            </a>
           </p>
          </td>
         </tr>
         <tr class="new-row">
          <td rowspan="2">
           <p>
            Producer operation
           </p>
          </td>
          <td>
           <p>
            Instance method
           </p>
          </td>
          <td>
           <p>
            <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#trim--">
             <code>
              String.trim()
             </code>
            </a>
           </p>
          </td>
         </tr>
         <tr>
          <td>
           <p>
            Static method
           </p>
          </td>
          <td>
           <p>
            <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-">
             <code>
              Collections.unmodifiableList()
             </code>
            </a>
           </p>
          </td>
         </tr>
         <tr class="new-row">
          <td rowspan="2">
           <p>
            Mutator operation
           </p>
          </td>
          <td>
           <p>
            Instance method
           </p>
          </td>
          <td>
           <p>
            <a href="http://docs.oracle.com/javase/8/docs/api/java/util/List.html#add-E-">
             <code>
              List.add()
             </code>
            </a>
           </p>
          </td>
         </tr>
         <tr>
          <td>
           <p>
            Static method
           </p>
          </td>
          <td>
           <p>
            <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#copy-java.util.List-java.util.List-">
             <code>
              Collections.copy()
             </code>
            </a>
           </p>
          </td>
         </tr>
         <tr class="new-row">
          <td>
           <p>
            Representation
           </p>
          </td>
          <td>
           <p>
            <code>
             private
            </code>
            fields
           </p>
          </td>
          <td>
          </td>
         </tr>
        </tbody>
       </table>
      </div>
      <h2 id="testing_an_abstract_data_type">
       Testing an Abstract Data Type
      </h2>
      <div data-outline="testing_an_abstract_data_type">
       <p>
        We build a test suite for an abstract data type by creating tests for each of its operations.
These tests inevitably interact with each other.  The only way to test creators, producers, and mutators is by calling observers on the objects that result, and likewise, the only way to test observers is by creating objects for them to observe.
       </p>
       <p>
        Here’s how we might partition the input spaces of the four operations in our
        <code>
         MyString
        </code>
        type:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-comment">// testing strategy for each operation of MyString:</span>
<span class="hljs-comment">//</span>
<span class="hljs-comment">// valueOf():</span>
<span class="hljs-comment">//    true, false</span>
<span class="hljs-comment">// length(): </span>
<span class="hljs-comment">//    string len = 0, 1, n</span>
<span class="hljs-comment">//    string = produced by valueOf(), produced by substring()</span>
<span class="hljs-comment">// charAt(): </span>
<span class="hljs-comment">//    string len = 1, n</span>
<span class="hljs-comment">//    i = 0, middle, len-1</span>
<span class="hljs-comment">//    string = produced by valueOf(), produced by substring()</span>
<span class="hljs-comment">// substring():</span>
<span class="hljs-comment">//    string len = 0, 1, n</span>
<span class="hljs-comment">//    start = 0, middle, len</span>
<span class="hljs-comment">//    end = 0, middle, len</span>
<span class="hljs-comment">//    end-start = 0, n</span>
<span class="hljs-comment">//    string = produced by valueOf(), produced by substring()</span></code></pre>
       <p>
        Then a compact test suite that covers all these partitions might look like:
       </p>
       <pre><code class="language-java hljs"><span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testValueOfTrue</span><span class="hljs-params">()</span> </span>{
    MyString s = MyString.valueOf(<span class="hljs-keyword">true</span>);
    assertEquals(<span class="hljs-number">4</span>, s.length());
    assertEquals(<span class="hljs-string">'t'</span>, s.charAt(<span class="hljs-number">0</span>));
    assertEquals(<span class="hljs-string">'r'</span>, s.charAt(<span class="hljs-number">1</span>));
    assertEquals(<span class="hljs-string">'u'</span>, s.charAt(<span class="hljs-number">2</span>));
    assertEquals(<span class="hljs-string">'e'</span>, s.charAt(<span class="hljs-number">3</span>));
}

<span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testValueOfFalse</span><span class="hljs-params">()</span> </span>{
    MyString s = MyString.valueOf(<span class="hljs-keyword">false</span>);
    assertEquals(<span class="hljs-number">5</span>, s.length());
    assertEquals(<span class="hljs-string">'f'</span>, s.charAt(<span class="hljs-number">0</span>));
    assertEquals(<span class="hljs-string">'a'</span>, s.charAt(<span class="hljs-number">1</span>));
    assertEquals(<span class="hljs-string">'l'</span>, s.charAt(<span class="hljs-number">2</span>));
    assertEquals(<span class="hljs-string">'s'</span>, s.charAt(<span class="hljs-number">3</span>));
    assertEquals(<span class="hljs-string">'e'</span>, s.charAt(<span class="hljs-number">4</span>));
}

<span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testEndSubstring</span><span class="hljs-params">()</span> </span>{
    MyString s = MyString.valueOf(<span class="hljs-keyword">true</span>).substring(<span class="hljs-number">2</span>, <span class="hljs-number">4</span>);
    assertEquals(<span class="hljs-number">2</span>, s.length());
    assertEquals(<span class="hljs-string">'u'</span>, s.charAt(<span class="hljs-number">0</span>));
    assertEquals(<span class="hljs-string">'e'</span>, s.charAt(<span class="hljs-number">1</span>));
}

<span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMiddleSubstring</span><span class="hljs-params">()</span> </span>{
    MyString s = MyString.valueOf(<span class="hljs-keyword">false</span>).substring(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
    assertEquals(<span class="hljs-number">1</span>, s.length());
    assertEquals(<span class="hljs-string">'a'</span>, s.charAt(<span class="hljs-number">0</span>));
}

<span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSubstringIsWholeString</span><span class="hljs-params">()</span> </span>{
    MyString s = MyString.valueOf(<span class="hljs-keyword">false</span>).substring(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);
    assertEquals(<span class="hljs-number">5</span>, s.length());
    assertEquals(<span class="hljs-string">'f'</span>, s.charAt(<span class="hljs-number">0</span>));
    assertEquals(<span class="hljs-string">'a'</span>, s.charAt(<span class="hljs-number">1</span>));
    assertEquals(<span class="hljs-string">'l'</span>, s.charAt(<span class="hljs-number">2</span>));
    assertEquals(<span class="hljs-string">'s'</span>, s.charAt(<span class="hljs-number">3</span>));
    assertEquals(<span class="hljs-string">'e'</span>, s.charAt(<span class="hljs-number">4</span>));
}

<span class="hljs-meta">@Test</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSubstringOfEmptySubstring</span><span class="hljs-params">()</span> </span>{
    MyString s = MyString.valueOf(<span class="hljs-keyword">false</span>).substring(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>).substring(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    assertEquals(<span class="hljs-number">0</span>, s.length());
}</code></pre>
       <p>
        Notice that each test case typically calls a few operations that
        <em>
         make
        </em>
        or
        <em>
         modify
        </em>
        objects of the type (creators, producers, mutators) and some operations that
        <em>
         inspect
        </em>
        objects of the type (observers).
As a result, each test case covers parts of several operations.
       </p>
      </div>
      <h2 id="summary">
       Summary
      </h2>
      <div data-outline="summary">
       <ul>
        <li>
         Abstract data types are characterized by their operations.
        </li>
        <li>
         Operations can be classified into creators, producers, observers, and mutators.
        </li>
        <li>
         An ADT’s specification is its set of operations and their specs.
        </li>
        <li>
         A good ADT is simple, coherent, adequate, and representation-independent.
        </li>
        <li>
         An ADT is tested by generating tests for each of its operations, but using the creators, producers, mutators, and observers together in the same tests.
        </li>
       </ul>
       <p>
        These ideas connect to our three key properties of good software as follows:
       </p>
       <ul>
        <li>
         <p>
          <strong>
           Safe from bugs.
          </strong>
          A good ADT offers a well-defined contract for a data type, so that clients know what to expect from the data type, and implementors have well-defined freedom to vary.
         </p>
        </li>
        <li>
         <p>
          <strong>
           Easy to understand.
          </strong>
          A good ADT hides its implementation behind a set of simple operations, so that programmers using the ADT only need to understand the operations, not the details of the implementation.
         </p>
        </li>
        <li>
         <p>
          <strong>
           Ready for change.
          </strong>
          Representation independence allows the implementation of an abstract data type to change without requiring changes from its clients.
         </p>
        </li>
       </ul>
      </div>
     </div>
    </div>
   </div>
  </main>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript">
  </script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript">
  </script>
  <script src="../../web/handout-run.js" type="text/javascript">
  </script>
 </body>

<!-- Mirrored from ocw.mit.edu/ans7870/6/6.005/s16/classes/12-abstract-data-types/ by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 12 Dec 2025 10:35:52 GMT -->
</html>
<!-- Handout delivered Thu Feb 25 2016 21:32:53 GMT-0500 (EST) -->
